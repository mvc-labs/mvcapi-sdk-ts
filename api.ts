/* tslint:disable */
/* eslint-disable */
/**
 * MicrovisionChain API Document
 * API definition for MicrovisionChain provided apis
 *
 * The version of the OpenAPI document: 3.0.9
 * Contact: heqiming@metasv.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * The current balance for a particular address
 * @export
 * @interface AddressBalance
 */
export interface AddressBalance {
    /**
     * current address
     * @type {string}
     * @memberof AddressBalance
     */
    address?: string;
    /**
     * confirmed balance
     * @type {number}
     * @memberof AddressBalance
     */
    confirmed?: number;
    /**
     * unconfirmed balance
     * @type {number}
     * @memberof AddressBalance
     */
    unconfirmed?: number;
}
/**
 * Transaction history of the address.
 * @export
 * @interface AddressTx
 */
export interface AddressTx {
    /**
     * Paging flag
     * @type {string}
     * @memberof AddressTx
     */
    flag?: string;
    /**
     * The address of the record
     * @type {string}
     * @memberof AddressTx
     */
    address?: string;
    /**
     * timestamp of the tx
     * @type {number}
     * @memberof AddressTx
     */
    time?: number;
    /**
     * Block Height of the tx, -1 if not confirmed
     * @type {number}
     * @memberof AddressTx
     */
    height?: number;
    /**
     * total income of the address from this tx
     * @type {number}
     * @memberof AddressTx
     */
    income?: number;
    /**
     * total outcome of the address from this tx
     * @type {number}
     * @memberof AddressTx
     */
    outcome?: number;
    /**
     * txid of this record
     * @type {string}
     * @memberof AddressTx
     */
    txid?: string;
}
/**
 * Utxos by address(or addresses) order by height asc.
 * @export
 * @interface AddressUtxo
 */
export interface AddressUtxo {
    /**
     * paging flag
     * @type {string}
     * @memberof AddressUtxo
     */
    flag?: string;
    /**
     * Address of the utxo
     * @type {string}
     * @memberof AddressUtxo
     */
    address?: string;
    /**
     * txid of the utxo
     * @type {string}
     * @memberof AddressUtxo
     */
    txid?: string;
    /**
     * output index in the tx
     * @type {number}
     * @memberof AddressUtxo
     */
    outIndex?: number;
    /**
     * Value of the utxo
     * @type {number}
     * @memberof AddressUtxo
     */
    value?: number;
    /**
     * Height of the utxo, -1 if not confirmed
     * @type {number}
     * @memberof AddressUtxo
     */
    height?: number;
}
/**
 * Broadcast result
 * @export
 * @interface AsyncBroadcastResult
 */
export interface AsyncBroadcastResult {
    /**
     * the txid of this tx
     * @type {string}
     * @memberof AsyncBroadcastResult
     */
    txid?: string;
    /**
     * the state of this tx, possible values PENDING, BROADCASTED, INVALID, UNKNOWN
     * @type {string}
     * @memberof AsyncBroadcastResult
     */
    state?: string;
    /**
     * return messages if broadcast failed
     * @type {string}
     * @memberof AsyncBroadcastResult
     */
    message?: string;
}
/**
 * Batch broadcast result
 * @export
 * @interface BatchBroadcastResult
 */
export interface BatchBroadcastResult {
    /**
     * Already known transactions detected during processing (if there are any)
     * @type {Array<string>}
     * @memberof BatchBroadcastResult
     */
    known?: Array<string>;
    /**
     * Transactions accepted by the mempool and then evicted due to insufficient fee (if there are any)
     * @type {Array<string>}
     * @memberof BatchBroadcastResult
     */
    evicted?: Array<string>;
    /**
     * Transactions that failed to be accepted by the mempool (if there are any)
     * @type {Array<InvalidBroadCast>}
     * @memberof BatchBroadcastResult
     */
    invalid?: Array<InvalidBroadCast>;
}
/**
 * Detailed block header info.
 * @export
 * @interface BlockHeaderIndex
 */
export interface BlockHeaderIndex {
    /**
     * Block hash.
     * @type {string}
     * @memberof BlockHeaderIndex
     */
    blockHash?: string;
    /**
     * Block height.
     * @type {number}
     * @memberof BlockHeaderIndex
     */
    height?: number;
    /**
     * Block version.
     * @type {number}
     * @memberof BlockHeaderIndex
     */
    version?: number;
    /**
     * The block hash of the previous block.
     * @type {string}
     * @memberof BlockHeaderIndex
     */
    prevBlockHash?: string;
    /**
     * Hex formatted block merkle root.
     * @type {string}
     * @memberof BlockHeaderIndex
     */
    merkleRoot?: string;
    /**
     * Block timestamp.
     * @type {number}
     * @memberof BlockHeaderIndex
     */
    timestamp?: number;
    /**
     * Block median timestamp.
     * @type {number}
     * @memberof BlockHeaderIndex
     */
    medianTime?: number;
    /**
     * Miner total rewards, including miner fee.
     * @type {number}
     * @memberof BlockHeaderIndex
     */
    reward?: number;
    /**
     * Guessed miner name.
     * @type {string}
     * @memberof BlockHeaderIndex
     */
    miner?: string;
    /**
     * Miner address that received rewards.
     * @type {string}
     * @memberof BlockHeaderIndex
     */
    minerAddress?: string;
    /**
     * Total txs count included in the block.
     * @type {number}
     * @memberof BlockHeaderIndex
     */
    txCount?: number;
    /**
     * Total input count in the block.
     * @type {number}
     * @memberof BlockHeaderIndex
     */
    inputCount?: number;
    /**
     * Total output count in the block
     * @type {number}
     * @memberof BlockHeaderIndex
     */
    outputCount?: number;
    /**
     * Size of the block
     * @type {number}
     * @memberof BlockHeaderIndex
     */
    size?: number;
    /**
     * Target bits.
     * @type {number}
     * @memberof BlockHeaderIndex
     */
    bits?: number;
    /**
     * Block nonce
     * @type {number}
     * @memberof BlockHeaderIndex
     */
    nonce?: number;
    /**
     * Hex formated coinbase info.
     * @type {string}
     * @memberof BlockHeaderIndex
     */
    coinbase?: string;
}
/**
 * block header saved by partition page
 * @export
 * @interface BlockHeaderPage
 */
export interface BlockHeaderPage {
    /**
     * Block height.
     * @type {number}
     * @memberof BlockHeaderPage
     */
    height?: number;
    /**
     * Block hash.
     * @type {string}
     * @memberof BlockHeaderPage
     */
    blockHash?: string;
    /**
     * Block timestamp.
     * @type {number}
     * @memberof BlockHeaderPage
     */
    timestamp?: number;
    /**
     * current median time
     * @type {number}
     * @memberof BlockHeaderPage
     */
    medianTime?: number;
    /**
     * Miner total rewards, including miner fee.
     * @type {number}
     * @memberof BlockHeaderPage
     */
    reward?: number;
    /**
     * Guessed miner name.
     * @type {string}
     * @memberof BlockHeaderPage
     */
    miner?: string;
    /**
     * Total txs count included in the block.
     * @type {number}
     * @memberof BlockHeaderPage
     */
    txCount?: number;
    /**
     * Size of the block
     * @type {number}
     * @memberof BlockHeaderPage
     */
    size?: number;
}
/**
 * Tx simple info for block tx list.
 * @export
 * @interface BlockTx
 */
export interface BlockTx {
    /**
     * Transaction hash.
     * @type {string}
     * @memberof BlockTx
     */
    txid?: string;
    /**
     * Block height of this tx.
     * @type {number}
     * @memberof BlockTx
     */
    height?: number;
    /**
     * Hash of the block
     * @type {string}
     * @memberof BlockTx
     */
    blockHash?: string;
    /**
     * transaction size
     * @type {number}
     * @memberof BlockTx
     */
    size?: number;
    /**
     * Input count in this transaction
     * @type {number}
     * @memberof BlockTx
     */
    inputCount?: number;
    /**
     * Output count in this transaction.
     * @type {number}
     * @memberof BlockTx
     */
    outputCount?: number;
    /**
     * Lock time of this transaction
     * @type {number}
     * @memberof BlockTx
     */
    lockTime?: number;
    /**
     * Trasaction fee.
     * @type {number}
     * @memberof BlockTx
     */
    fee?: number;
    /**
     * Confirmations of this transaction, -1 if unconfirmed.
     * @type {number}
     * @memberof BlockTx
     */
    confirmations?: number;
    /**
     * Block timestamp for the transaction, confirmed tx only.
     * @type {number}
     * @memberof BlockTx
     */
    timestamp?: number;
}
/**
 * 
 * @export
 * @interface BlockchainInfo
 */
export interface BlockchainInfo {
    /**
     * mainnet or testnet
     * @type {string}
     * @memberof BlockchainInfo
     */
    chain?: string;
    /**
     * current block count
     * @type {number}
     * @memberof BlockchainInfo
     */
    blocks?: number;
    /**
     * current block header count
     * @type {number}
     * @memberof BlockchainInfo
     */
    headers?: number;
    /**
     * current highest blockhash
     * @type {string}
     * @memberof BlockchainInfo
     */
    bestBlockHash?: string;
    /**
     * decimal string for current difficulty
     * @type {string}
     * @memberof BlockchainInfo
     */
    difficulty?: string;
    /**
     * current median time
     * @type {number}
     * @memberof BlockchainInfo
     */
    medianTime?: number;
    /**
     * current pow
     * @type {string}
     * @memberof BlockchainInfo
     */
    chainwork?: string;
    /**
     * estimated current network hash rate.
     * @type {string}
     * @memberof BlockchainInfo
     */
    networkHashPerSecond?: string;
    /**
     * current mempool transaction count.
     * @type {number}
     * @memberof BlockchainInfo
     */
    mempoolTxCount?: number;
    /**
     * current mempool usage.
     * @type {number}
     * @memberof BlockchainInfo
     */
    mempoolUsage?: number;
    /**
     * next estimated block size.
     * @type {number}
     * @memberof BlockchainInfo
     */
    estimatedBlockSize?: number;
}
/**
 * Broadcast result
 * @export
 * @interface BroadcastResult
 */
export interface BroadcastResult {
    /**
     * return txid if broadcast success
     * @type {string}
     * @memberof BroadcastResult
     */
    txid?: string;
    /**
     * return messages if broadcast failed
     * @type {string}
     * @memberof BroadcastResult
     */
    message?: string;
}
/**
 * Request object to register(or delete) a new client public key.
 * @export
 * @interface ClientPubkeyRequest
 */
export interface ClientPubkeyRequest {
    /**
     * The hex format public key to register. (i.e. 02fd17dd0c52e54e5eed4ebe1e75df5e48df422f81c26520d44380bef1691fdd98)
     * @type {string}
     * @memberof ClientPubkeyRequest
     */
    pubkey?: string;
}
/**
 * Client public key result
 * @export
 * @interface ClientPubkeyResult
 */
export interface ClientPubkeyResult {
    /**
     * return pubkey if created successfully
     * @type {string}
     * @memberof ClientPubkeyResult
     */
    pubkey?: string;
    /**
     * return messages if broadcast failed
     * @type {string}
     * @memberof ClientPubkeyResult
     */
    message?: string;
}
/**
 * Transaction history of the address for specific ft.
 * @export
 * @interface ContractFtAddressTx
 */
export interface ContractFtAddressTx {
    /**
     * Paging flag
     * @type {string}
     * @memberof ContractFtAddressTx
     */
    flag?: string;
    /**
     * The address of the record
     * @type {string}
     * @memberof ContractFtAddressTx
     */
    address?: string;
    /**
     * Specific codeHash
     * @type {string}
     * @memberof ContractFtAddressTx
     */
    codeHash?: string;
    /**
     * specific genesis
     * @type {string}
     * @memberof ContractFtAddressTx
     */
    genesis?: string;
    /**
     * timestamp of the tx
     * @type {number}
     * @memberof ContractFtAddressTx
     */
    time?: number;
    /**
     * Block Height of the tx, -1 if not confirmed
     * @type {number}
     * @memberof ContractFtAddressTx
     */
    height?: number;
    /**
     * total income of the address from this tx
     * @type {number}
     * @memberof ContractFtAddressTx
     */
    income?: number;
    /**
     * total outcome of the address from this tx
     * @type {number}
     * @memberof ContractFtAddressTx
     */
    outcome?: number;
    /**
     * txid of this record
     * @type {string}
     * @memberof ContractFtAddressTx
     */
    txid?: string;
}
/**
 * Contract fungible token balance
 * @export
 * @interface ContractFtBalance
 */
export interface ContractFtBalance {
    /**
     * Codehash of the token.
     * @type {string}
     * @memberof ContractFtBalance
     */
    codeHash?: string;
    /**
     * Genesis of the token.
     * @type {string}
     * @memberof ContractFtBalance
     */
    genesis?: string;
    /**
     * Name of the token.
     * @type {string}
     * @memberof ContractFtBalance
     */
    name?: string;
    /**
     * Symbol of the token.
     * @type {string}
     * @memberof ContractFtBalance
     */
    symbol?: string;
    /**
     * The decimal position.
     * @type {number}
     * @memberof ContractFtBalance
     */
    decimal?: number;
    /**
     * SensibleId of the token
     * @type {string}
     * @memberof ContractFtBalance
     */
    sensibleId?: string;
    /**
     * Number of utxos for this token.
     * @type {number}
     * @memberof ContractFtBalance
     */
    utxoCount?: number;
    /**
     * Confirmed balance of the token.
     * @type {number}
     * @memberof ContractFtBalance
     */
    confirmed?: number;
    /**
     * Confirmed balance of the token(In string format).
     * @type {string}
     * @memberof ContractFtBalance
     */
    confirmedString?: string;
    /**
     * Unconfirmed balance of the token.
     * @type {number}
     * @memberof ContractFtBalance
     */
    unconfirmed?: number;
    /**
     * Unconfirmed balance of the token(In string format).
     * @type {string}
     * @memberof ContractFtBalance
     */
    unconfirmedString?: string;
}
/**
 * Get total circulation for specific genesis of ft token.
 * @export
 * @interface ContractFtGenesisCirculation
 */
export interface ContractFtGenesisCirculation {
    /**
     * Confirmed circulation of the token(Sum of confirmed amount).
     * @type {number}
     * @memberof ContractFtGenesisCirculation
     */
    confirmed?: number;
    /**
     * Unconfirmed circulation of the token(Unconfirmed new token - Unconfirmed spent).
     * @type {number}
     * @memberof ContractFtGenesisCirculation
     */
    unconfirmed?: number;
}
/**
 * Contract fungible token Utxo belongs to the specified address
 * @export
 * @interface ContractFtUtxo
 */
export interface ContractFtUtxo {
    /**
     * Address string of this utxo
     * @type {string}
     * @memberof ContractFtUtxo
     */
    address?: string;
    /**
     * Codehash of this utxo.
     * @type {string}
     * @memberof ContractFtUtxo
     */
    codeHash?: string;
    /**
     * Genesis of this utxo.
     * @type {string}
     * @memberof ContractFtUtxo
     */
    genesis?: string;
    /**
     * Name of the token.
     * @type {string}
     * @memberof ContractFtUtxo
     */
    name?: string;
    /**
     * Symbol of the token.
     * @type {string}
     * @memberof ContractFtUtxo
     */
    symbol?: string;
    /**
     * SensibleId of the token
     * @type {string}
     * @memberof ContractFtUtxo
     */
    sensibleId?: string;
    /**
     * The decimal position.
     * @type {number}
     * @memberof ContractFtUtxo
     */
    decimal?: number;
    /**
     * Txid for this utxo.
     * @type {string}
     * @memberof ContractFtUtxo
     */
    txid?: string;
    /**
     * Output index for the Utxo.
     * @type {number}
     * @memberof ContractFtUtxo
     */
    txIndex?: number;
    /**
     * Token value of the utxo(Irrelavant to satoshi value).
     * @type {number}
     * @memberof ContractFtUtxo
     */
    value?: number;
    /**
     * Token value of the utxo(In string format)
     * @type {string}
     * @memberof ContractFtUtxo
     */
    valueString?: string;
    /**
     * Mvc value of the utxo(Irrelavant to token value)
     * @type {number}
     * @memberof ContractFtUtxo
     */
    satoshi?: number;
    /**
     * Mvc value of the utxo(In string format)
     * @type {string}
     * @memberof ContractFtUtxo
     */
    satoshiString?: string;
    /**
     * The height of this utxo, -1 for unconfirmed utxo.
     * @type {number}
     * @memberof ContractFtUtxo
     */
    height?: number;
    /**
     * Flag used for paging
     * @type {string}
     * @memberof ContractFtUtxo
     */
    flag?: string;
}
/**
 * Get nft summary(count group by genesis) for specific address.
 * @export
 * @interface ContractNftAddressSummary
 */
export interface ContractNftAddressSummary {
    /**
     * Codehash of this NFT series.
     * @type {string}
     * @memberof ContractNftAddressSummary
     */
    codeHash?: string;
    /**
     * Genesis of this NFT series..
     * @type {string}
     * @memberof ContractNftAddressSummary
     */
    genesis?: string;
    /**
     * SensibleId of the token
     * @type {string}
     * @memberof ContractNftAddressSummary
     */
    sensibleId?: string;
    /**
     * The metanet tx describing the nft.
     * @type {string}
     * @memberof ContractNftAddressSummary
     */
    metaTxid?: string;
    /**
     * Symbol of the token.
     * @type {number}
     * @memberof ContractNftAddressSummary
     */
    metaOutputIndex?: number;
    /**
     * The total supply of this NFT.
     * @type {number}
     * @memberof ContractNftAddressSummary
     */
    tokenSupply?: number;
    /**
     * The count of this nft that the address owns.
     * @type {number}
     * @memberof ContractNftAddressSummary
     */
    count?: number;
}
/**
 * Contract nft auction Utxo belongs to the specified address
 * @export
 * @interface ContractNftAuctionUtxo
 */
export interface ContractNftAuctionUtxo {
    /**
     * Address string of this utxo
     * @type {string}
     * @memberof ContractNftAuctionUtxo
     */
    address?: string;
    /**
     * Txid for this utxo.
     * @type {string}
     * @memberof ContractNftAuctionUtxo
     */
    txid?: string;
    /**
     * Output index for the Utxo.
     * @type {number}
     * @memberof ContractNftAuctionUtxo
     */
    txIndex?: number;
    /**
     * bidMvcPrice
     * @type {number}
     * @memberof ContractNftAuctionUtxo
     */
    bidMvcPrice?: number;
    /**
     * bidTimestamp
     * @type {number}
     * @memberof ContractNftAuctionUtxo
     */
    bidTimestamp?: number;
    /**
     * bidderAddressPkh
     * @type {string}
     * @memberof ContractNftAuctionUtxo
     */
    bidderAddressPkh?: string;
    /**
     * Codehash of this utxo.
     * @type {string}
     * @memberof ContractNftAuctionUtxo
     */
    codeHash?: string;
    /**
     * Genesis of this utxo.
     * @type {string}
     * @memberof ContractNftAuctionUtxo
     */
    genesis?: string;
    /**
     * endTimestamp
     * @type {number}
     * @memberof ContractNftAuctionUtxo
     */
    endTimestamp?: number;
    /**
     * feeAddressPkh
     * @type {string}
     * @memberof ContractNftAuctionUtxo
     */
    feeAddressPkh?: string;
    /**
     * feeAmount
     * @type {number}
     * @memberof ContractNftAuctionUtxo
     */
    feeAmount?: number;
    /**
     * feeRate
     * @type {number}
     * @memberof ContractNftAuctionUtxo
     */
    feeRate?: number;
    /**
     * The height of this utxo, -1 for unconfirmed utxo.
     * @type {number}
     * @memberof ContractNftAuctionUtxo
     */
    height?: number;
    /**
     * nftCodeHash
     * @type {string}
     * @memberof ContractNftAuctionUtxo
     */
    nftCodeHash?: string;
    /**
     * nftId of the auctioning fnt
     * @type {string}
     * @memberof ContractNftAuctionUtxo
     */
    nftId?: string;
    /**
     * senderAddressPkh
     * @type {string}
     * @memberof ContractNftAuctionUtxo
     */
    senderAddressPkh?: string;
    /**
     * SensibleId of the utxo
     * @type {string}
     * @memberof ContractNftAuctionUtxo
     */
    sensibleId?: string;
    /**
     * startMvcPrice
     * @type {number}
     * @memberof ContractNftAuctionUtxo
     */
    startMvcPrice?: number;
    /**
     * Mvc value of the utxo(Irrelavant to token value)
     * @type {number}
     * @memberof ContractNftAuctionUtxo
     */
    satoshi?: number;
    /**
     * Mvc value of the utxo(In string format)
     * @type {string}
     * @memberof ContractNftAuctionUtxo
     */
    satoshiString?: string;
    /**
     * The hash160 of the script(p2ch address)
     * @type {string}
     * @memberof ContractNftAuctionUtxo
     */
    contractAddress?: string;
    /**
     * this the nft send to this contract address
     * @type {boolean}
     * @memberof ContractNftAuctionUtxo
     */
    isReady?: boolean;
    /**
     * Flag used for paging
     * @type {string}
     * @memberof ContractNftAuctionUtxo
     */
    flag?: string;
}
/**
 * Get summary(count group by address) for specific genesis.
 * @export
 * @interface ContractNftGenesisSummary
 */
export interface ContractNftGenesisSummary {
    /**
     * Owner address.
     * @type {string}
     * @memberof ContractNftGenesisSummary
     */
    address?: string;
    /**
     * SensibleId of the token
     * @type {string}
     * @memberof ContractNftGenesisSummary
     */
    sensibleId?: string;
    /**
     * The metanet tx describing the nft.
     * @type {string}
     * @memberof ContractNftGenesisSummary
     */
    metaTxid?: string;
    /**
     * Symbol of the token.
     * @type {number}
     * @memberof ContractNftGenesisSummary
     */
    metaOutputIndex?: number;
    /**
     * The total supply of this NFT.
     * @type {number}
     * @memberof ContractNftGenesisSummary
     */
    tokenSupply?: number;
    /**
     * The count of this nft that the address owns.
     * @type {number}
     * @memberof ContractNftGenesisSummary
     */
    count?: number;
}
/**
 * Contract nft sell Utxo belongs to the specified address
 * @export
 * @interface ContractNftSellUtxo
 */
export interface ContractNftSellUtxo {
    /**
     * Address string of this utxo
     * @type {string}
     * @memberof ContractNftSellUtxo
     */
    address?: string;
    /**
     * Address calculated from contract hash(p2ch).
     * @type {string}
     * @memberof ContractNftSellUtxo
     */
    contractAddress?: string;
    /**
     * Txid for this utxo.
     * @type {string}
     * @memberof ContractNftSellUtxo
     */
    txid?: string;
    /**
     * Output index for the Utxo.
     * @type {number}
     * @memberof ContractNftSellUtxo
     */
    txIndex?: number;
    /**
     * Codehash of this utxo.
     * @type {string}
     * @memberof ContractNftSellUtxo
     */
    codeHash?: string;
    /**
     * Genesis of this utxo.
     * @type {string}
     * @memberof ContractNftSellUtxo
     */
    genesis?: string;
    /**
     * The index of this NFT.
     * @type {number}
     * @memberof ContractNftSellUtxo
     */
    tokenIndex?: number;
    /**
     * the price of nft.
     * @type {number}
     * @memberof ContractNftSellUtxo
     */
    price?: number;
    /**
     * Mvc value of the utxo(Irrelavant to token value)
     * @type {number}
     * @memberof ContractNftSellUtxo
     */
    satoshi?: number;
    /**
     * Mvc value of the utxo(In string format)
     * @type {string}
     * @memberof ContractNftSellUtxo
     */
    satoshiString?: string;
    /**
     * The height of this utxo, -1 for unconfirmed utxo.
     * @type {number}
     * @memberof ContractNftSellUtxo
     */
    height?: number;
    /**
     * Is current nft transfered into sell contract, If not ready, the following fields will be null
     * @type {boolean}
     * @memberof ContractNftSellUtxo
     */
    isReady?: boolean;
    /**
     * SensibleId of the token
     * @type {string}
     * @memberof ContractNftSellUtxo
     */
    sensibleId?: string;
    /**
     * The metanet tx describing the nft.
     * @type {string}
     * @memberof ContractNftSellUtxo
     */
    metaTxid?: string;
    /**
     * Symbol of the token.
     * @type {number}
     * @memberof ContractNftSellUtxo
     */
    metaOutputIndex?: number;
    /**
     * The total supply of this NFT.
     * @type {number}
     * @memberof ContractNftSellUtxo
     */
    tokenSupply?: number;
    /**
     * Flag used for paging
     * @type {string}
     * @memberof ContractNftSellUtxo
     */
    flag?: string;
}
/**
 * Contract nft sell v2 Utxo belongs to the specified address
 * @export
 * @interface ContractNftSellV2Utxo
 */
export interface ContractNftSellV2Utxo {
    /**
     * Address string of this utxo
     * @type {string}
     * @memberof ContractNftSellV2Utxo
     */
    address?: string;
    /**
     * Address calculated from contract hash(p2ch).
     * @type {string}
     * @memberof ContractNftSellV2Utxo
     */
    contractAddress?: string;
    /**
     * Txid for this utxo.
     * @type {string}
     * @memberof ContractNftSellV2Utxo
     */
    txid?: string;
    /**
     * Output index for the Utxo.
     * @type {number}
     * @memberof ContractNftSellV2Utxo
     */
    txIndex?: number;
    /**
     * Codehash of this utxo.
     * @type {string}
     * @memberof ContractNftSellV2Utxo
     */
    codeHash?: string;
    /**
     * Genesis of this utxo.
     * @type {string}
     * @memberof ContractNftSellV2Utxo
     */
    genesis?: string;
    /**
     * The index of this NFT.
     * @type {number}
     * @memberof ContractNftSellV2Utxo
     */
    tokenIndex?: number;
    /**
     * the price of nft.
     * @type {number}
     * @memberof ContractNftSellV2Utxo
     */
    price?: number;
    /**
     * The address to receive fees.
     * @type {string}
     * @memberof ContractNftSellV2Utxo
     */
    feeAddressPkh?: string;
    /**
     * feeRate
     * @type {number}
     * @memberof ContractNftSellV2Utxo
     */
    feeRate?: number;
    /**
     * nftId
     * @type {string}
     * @memberof ContractNftSellV2Utxo
     */
    nftId?: string;
    /**
     * The address pkh of seller
     * @type {string}
     * @memberof ContractNftSellV2Utxo
     */
    sellerAddressPkh?: string;
    /**
     * Mvc value of the utxo(Irrelavant to token value)
     * @type {number}
     * @memberof ContractNftSellV2Utxo
     */
    satoshi?: number;
    /**
     * Mvc value of the utxo(In string format)
     * @type {string}
     * @memberof ContractNftSellV2Utxo
     */
    satoshiString?: string;
    /**
     * The height of this utxo, -1 for unconfirmed utxo.
     * @type {number}
     * @memberof ContractNftSellV2Utxo
     */
    height?: number;
    /**
     * Is current nft transfered into sell contract, If not ready, the following fields will be null
     * @type {boolean}
     * @memberof ContractNftSellV2Utxo
     */
    isReady?: boolean;
    /**
     * SensibleId of the token
     * @type {string}
     * @memberof ContractNftSellV2Utxo
     */
    sensibleId?: string;
    /**
     * The metanet tx describing the nft.
     * @type {string}
     * @memberof ContractNftSellV2Utxo
     */
    metaTxid?: string;
    /**
     * Symbol of the token.
     * @type {number}
     * @memberof ContractNftSellV2Utxo
     */
    metaOutputIndex?: number;
    /**
     * The total supply of this NFT.
     * @type {number}
     * @memberof ContractNftSellV2Utxo
     */
    tokenSupply?: number;
    /**
     * Flag used for paging
     * @type {string}
     * @memberof ContractNftSellV2Utxo
     */
    flag?: string;
}
/**
 * Contract non fungible token Utxo belongs to the specified address
 * @export
 * @interface ContractNftUtxo
 */
export interface ContractNftUtxo {
    /**
     * Address string of this utxo
     * @type {string}
     * @memberof ContractNftUtxo
     */
    address?: string;
    /**
     * Txid for this utxo.
     * @type {string}
     * @memberof ContractNftUtxo
     */
    txid?: string;
    /**
     * Output index for the Utxo.
     * @type {number}
     * @memberof ContractNftUtxo
     */
    txIndex?: number;
    /**
     * Codehash of this utxo.
     * @type {string}
     * @memberof ContractNftUtxo
     */
    codeHash?: string;
    /**
     * Genesis of this utxo.
     * @type {string}
     * @memberof ContractNftUtxo
     */
    genesis?: string;
    /**
     * SensibleId of the token
     * @type {string}
     * @memberof ContractNftUtxo
     */
    sensibleId?: string;
    /**
     * The height of this utxo, -1 for unconfirmed utxo.
     * @type {number}
     * @memberof ContractNftUtxo
     */
    height?: number;
    /**
     * The metanet tx describing the nft.
     * @type {string}
     * @memberof ContractNftUtxo
     */
    metaTxid?: string;
    /**
     * Symbol of the token.
     * @type {number}
     * @memberof ContractNftUtxo
     */
    metaOutputIndex?: number;
    /**
     * The total supply of this NFT.
     * @type {number}
     * @memberof ContractNftUtxo
     */
    tokenSupply?: number;
    /**
     * The index of this NFT.
     * @type {number}
     * @memberof ContractNftUtxo
     */
    tokenIndex?: number;
    /**
     * Mvc value of the utxo(Irrelavant to token value)
     * @type {number}
     * @memberof ContractNftUtxo
     */
    satoshi?: number;
    /**
     * Mvc value of the utxo(In string format)
     * @type {string}
     * @memberof ContractNftUtxo
     */
    satoshiString?: string;
    /**
     * Flag used for paging
     * @type {string}
     * @memberof ContractNftUtxo
     */
    flag?: string;
}
/**
 * Contract unique Utxo indexed by codeHash and genesis.
 * @export
 * @interface ContractUniqueUtxo
 */
export interface ContractUniqueUtxo {
    /**
     * Txid for this utxo.
     * @type {string}
     * @memberof ContractUniqueUtxo
     */
    txid?: string;
    /**
     * Output index for the Utxo.
     * @type {number}
     * @memberof ContractUniqueUtxo
     */
    txIndex?: number;
    /**
     * Codehash of this utxo.
     * @type {string}
     * @memberof ContractUniqueUtxo
     */
    codeHash?: string;
    /**
     * Genesis of this utxo.
     * @type {string}
     * @memberof ContractUniqueUtxo
     */
    genesis?: string;
    /**
     * SensibleId of the token
     * @type {string}
     * @memberof ContractUniqueUtxo
     */
    sensibleId?: string;
    /**
     * The height of this utxo, -1 for unconfirmed utxo.
     * @type {number}
     * @memberof ContractUniqueUtxo
     */
    height?: number;
    /**
     * The hex encoded customData
     * @type {string}
     * @memberof ContractUniqueUtxo
     */
    customData?: string;
    /**
     * Mvc value of the utxo(Irrelavant to token value)
     * @type {number}
     * @memberof ContractUniqueUtxo
     */
    satoshi?: number;
    /**
     * Mvc value of the utxo(In string format)
     * @type {string}
     * @memberof ContractUniqueUtxo
     */
    satoshiString?: string;
}
/**
 * Error response.
 * @export
 * @interface ErrorResponse
 */
export interface ErrorResponse {
    /**
     * The reason for this error.
     * @type {string}
     * @memberof ErrorResponse
     */
    message?: string;
}
/**
 * Invalid transactions detected during validation (if there are any)
 * @export
 * @interface InvalidBroadCast
 */
export interface InvalidBroadCast {
    /**
     * return txid if broadcast success
     * @type {string}
     * @memberof InvalidBroadCast
     */
    txid?: string;
    /**
     * return messages if broadcast failed
     * @type {number}
     * @memberof InvalidBroadCast
     */
    reject_code?: number;
    /**
     * return messages if broadcast failed
     * @type {string}
     * @memberof InvalidBroadCast
     */
    reject_reason?: string;
    /**
     * return messages if broadcast failed
     * @type {Array<InvalidBroadcastCollide>}
     * @memberof InvalidBroadCast
     */
    collideWith?: Array<InvalidBroadcastCollide>;
}
/**
 * This field is only present in case of double spent transaction and contains transactions we collided with
 * @export
 * @interface InvalidBroadcastCollide
 */
export interface InvalidBroadcastCollide {
    /**
     * The transaction id
     * @type {string}
     * @memberof InvalidBroadcastCollide
     */
    txid?: string;
    /**
     * Transaction size in bytes
     * @type {number}
     * @memberof InvalidBroadcastCollide
     */
    size?: number;
    /**
     * Whole transaction in hex
     * @type {string}
     * @memberof InvalidBroadcastCollide
     */
    hex?: string;
}
/**
 * spent status and value info of the output.
 * @export
 * @interface OutputInfo
 */
export interface OutputInfo {
    /**
     * txid that this output is in.
     * @type {string}
     * @memberof OutputInfo
     */
    txid?: string;
    /**
     * index of this output in the tx.
     * @type {number}
     * @memberof OutputInfo
     */
    index?: number;
    /**
     * parsed address of this output, empty for non standard.
     * @type {string}
     * @memberof OutputInfo
     */
    address?: string;
    /**
     * value of this output
     * @type {number}
     * @memberof OutputInfo
     */
    value?: number;
    /**
     * this output is spent or not, true if spent
     * @type {boolean}
     * @memberof OutputInfo
     */
    spent?: boolean;
    /**
     * txid that spent this output
     * @type {string}
     * @memberof OutputInfo
     */
    spentTxid?: string;
    /**
     * vin index of the spent tx
     * @type {number}
     * @memberof OutputInfo
     */
    spentIndex?: number;
    /**
     * height of the spent tx(-1 if unconfirmed, 0 if unspent)
     * @type {number}
     * @memberof OutputInfo
     */
    spentHeight?: number;
}
/**
 * spent status and value info of the output with detailed output script.
 * @export
 * @interface OutputInfoDetail
 */
export interface OutputInfoDetail {
    /**
     * txid that this output is in.
     * @type {string}
     * @memberof OutputInfoDetail
     */
    txid?: string;
    /**
     * index of this output in the tx.
     * @type {number}
     * @memberof OutputInfoDetail
     */
    index?: number;
    /**
     * output scrypt in hex format
     * @type {string}
     * @memberof OutputInfoDetail
     */
    script?: string;
    /**
     * parsed address of this output, empty for non standard.
     * @type {string}
     * @memberof OutputInfoDetail
     */
    address?: string;
    /**
     * value of this output
     * @type {number}
     * @memberof OutputInfoDetail
     */
    value?: number;
    /**
     * this output is spent or not, true if spent
     * @type {boolean}
     * @memberof OutputInfoDetail
     */
    spent?: boolean;
    /**
     * txid that spent this output
     * @type {string}
     * @memberof OutputInfoDetail
     */
    spentTxid?: string;
    /**
     * vin index of the spent tx
     * @type {number}
     * @memberof OutputInfoDetail
     */
    spentIndex?: number;
    /**
     * height of the spent tx(-1 if unconfirmed, 0 if unspent)
     * @type {number}
     * @memberof OutputInfoDetail
     */
    spentHeight?: number;
}
/**
 * treasury transaction history
 * @export
 * @interface TreasuryHistory
 */
export interface TreasuryHistory {
    /**
     * treasury transaction txid.
     * @type {string}
     * @memberof TreasuryHistory
     */
    txid?: string;
    /**
     * treasury transaction spent outcome in satoshi.
     * @type {number}
     * @memberof TreasuryHistory
     */
    outcome?: number;
    /**
     * treasury transaction timestamp.
     * @type {number}
     * @memberof TreasuryHistory
     */
    timestamp?: number;
    /**
     * Reason for treasury transaction.
     * @type {string}
     * @memberof TreasuryHistory
     */
    reason?: string;
    /**
     * Announcement link for treasury transaction.
     * @type {string}
     * @memberof TreasuryHistory
     */
    announcementUrl?: string;
}
/**
 * current treasury utxo info
 * @export
 * @interface TreasuryInfo
 */
export interface TreasuryInfo {
    /**
     * current treasury utxo txid
     * @type {string}
     * @memberof TreasuryInfo
     */
    txid?: string;
    /**
     * current treasury utxo index
     * @type {number}
     * @memberof TreasuryInfo
     */
    index?: number;
    /**
     * current treasury amount
     * @type {number}
     * @memberof TreasuryInfo
     */
    amount?: number;
    /**
     * current treasury utxo height
     * @type {number}
     * @memberof TreasuryInfo
     */
    height?: number;
    /**
     * current treasury utxo block hash
     * @type {string}
     * @memberof TreasuryInfo
     */
    blockHash?: string;
    /**
     * current treasury utxo timestamp
     * @type {number}
     * @memberof TreasuryInfo
     */
    timestamp?: number;
}
/**
 * Parsed tx info
 * @export
 * @interface TxDetail
 */
export interface TxDetail {
    /**
     * 
     * @type {BlockTx}
     * @memberof TxDetail
     */
    txDetail?: BlockTx;
    /**
     * 
     * @type {Array<TxInput>}
     * @memberof TxDetail
     */
    inputs?: Array<TxInput>;
    /**
     * 
     * @type {Array<TxOutput>}
     * @memberof TxDetail
     */
    outputs?: Array<TxOutput>;
}
/**
 * Parsed inputs from raw tx. Use output api to get value and spent info.
 * @export
 * @interface TxInput
 */
export interface TxInput {
    /**
     * Input index of the tx.
     * @type {number}
     * @memberof TxInput
     */
    index?: number;
    /**
     * The outpoint utxo txid that this input spent
     * @type {string}
     * @memberof TxInput
     */
    utxoTxid?: string;
    /**
     * The outpoint utxo index that this input spent
     * @type {number}
     * @memberof TxInput
     */
    utxoIndex?: number;
    /**
     * Parsed address from pubkey(P2PKH input only).
     * @type {string}
     * @memberof TxInput
     */
    address?: string;
    /**
     * satoshi value of this input.
     * @type {number}
     * @memberof TxInput
     */
    value?: number;
    /**
     * The hex of the input script.
     * @type {string}
     * @memberof TxInput
     */
    unlockScript?: string;
}
/**
 * Parsed outputs from raw tx.
 * @export
 * @interface TxOutput
 */
export interface TxOutput {
    /**
     * Output index of the tx.
     * @type {number}
     * @memberof TxOutput
     */
    index?: number;
    /**
     * Bitcoin Value in this output.
     * @type {number}
     * @memberof TxOutput
     */
    value?: number;
    /**
     * Parsed address from output
     * @type {string}
     * @memberof TxOutput
     */
    address?: string;
    /**
     * Hex formatted lockScript
     * @type {string}
     * @memberof TxOutput
     */
    lockScript?: string;
}
/**
 * Raw hex formatted Tx returned.
 * @export
 * @interface TxRaw
 */
export interface TxRaw {
    /**
     * hex formatted raw tx.
     * @type {string}
     * @memberof TxRaw
     */
    hex?: string;
}
/**
 * Request object to batch pick utxo
 * @export
 * @interface UtxoPickRequest
 */
export interface UtxoPickRequest {
    /**
     * The address list to pick utxo from
     * @type {Array<string>}
     * @memberof UtxoPickRequest
     */
    addresses?: Array<string>;
    /**
     * The total amount you want to pick
     * @type {number}
     * @memberof UtxoPickRequest
     */
    amount?: number;
}
/**
 * Xpub transaction history
 * @export
 * @interface XPubTransaction
 */
export interface XPubTransaction {
    /**
     * query xpub
     * @type {string}
     * @memberof XPubTransaction
     */
    xpub?: string;
    /**
     * Txid for this transaction.
     * @type {string}
     * @memberof XPubTransaction
     */
    txid?: string;
    /**
     * Max lookahead receive index when processing this transaction.
     * @type {number}
     * @memberof XPubTransaction
     */
    maxReceiveIndex?: number;
    /**
     * Max lookahead change index when processing this transaction.
     * @type {number}
     * @memberof XPubTransaction
     */
    maxChangeIndex?: number;
    /**
     * Total received satoshis(Including all address)
     * @type {number}
     * @memberof XPubTransaction
     */
    income?: number;
    /**
     * Total spent satoshis(Including all address)
     * @type {number}
     * @memberof XPubTransaction
     */
    outcome?: number;
    /**
     * Height for this transaction. -1 for unconfirmed
     * @type {number}
     * @memberof XPubTransaction
     */
    height?: number;
    /**
     * Block index for this transaction, -1 for unconfirmed
     * @type {number}
     * @memberof XPubTransaction
     */
    blockIndex?: number;
    /**
     * Block timestamp for this transaction, if unconfirmed, the time is first seen time.
     * @type {number}
     * @memberof XPubTransaction
     */
    blockTime?: number;
    /**
     * Paging flag, format blockTimestamp_blockIndex
     * @type {string}
     * @memberof XPubTransaction
     */
    flag?: string;
}
/**
 * Address detail in the wallet
 * @export
 * @interface XpubAddress
 */
export interface XpubAddress {
    /**
     * xpub in the query
     * @type {string}
     * @memberof XpubAddress
     */
    xpub?: string;
    /**
     * Address in the query
     * @type {string}
     * @memberof XpubAddress
     */
    address?: string;
    /**
     * Address type, 0 for receive address, 1 for change address. path is {{addressType}}/{{addressIndex}}
     * @type {number}
     * @memberof XpubAddress
     */
    addressType?: number;
    /**
     * Address index. Address path in the xpub is {{addressType}}/{{addressIndex}}
     * @type {number}
     * @memberof XpubAddress
     */
    addressIndex?: number;
}
/**
 * Registered Xpub balance including confirmed and unconfirmed
 * @export
 * @interface XpubBalance
 */
export interface XpubBalance {
    /**
     * confirmed balance
     * @type {number}
     * @memberof XpubBalance
     */
    confirmed?: number;
    /**
     * unconfirmed balance
     * @type {number}
     * @memberof XpubBalance
     */
    unconfirmed?: number;
}
/**
 * Registered Xpub detail
 * @export
 * @interface XpubDetail
 */
export interface XpubDetail {
    /**
     * String encoded extended pubkey (xpub)
     * @type {string}
     * @memberof XpubDetail
     */
    xpub?: string;
    /**
     * Next unused receive index, path /0/index
     * @type {number}
     * @memberof XpubDetail
     */
    receiveIndex?: number;
    /**
     * Max lookahead receive index.
     * @type {number}
     * @memberof XpubDetail
     */
    maxReceiveIndex?: number;
    /**
     * Next unused change index, path /1/index
     * @type {number}
     * @memberof XpubDetail
     */
    changeIndex?: number;
    /**
     * Max lookahead change index.
     * @type {number}
     * @memberof XpubDetail
     */
    maxChangeIndex?: number;
    /**
     * Current xpub process mode, 0 means preparing(not ready), 1 means synchronizing(ready)
     * @type {number}
     * @memberof XpubDetail
     */
    mode?: number;
    /**
     * Skip blocks before skipHeight while searching transactions. This will speed up sync time.
     * @type {number}
     * @memberof XpubDetail
     */
    skipHeight?: number;
    /**
     * Xpub current processed height.
     * @type {number}
     * @memberof XpubDetail
     */
    processHeight?: number;
}
/**
 * Balance for xpub lite wallet
 * @export
 * @interface XpubLiteBalance
 */
export interface XpubLiteBalance {
    /**
     * confirmed balance plus unconfirmed balance
     * @type {number}
     * @memberof XpubLiteBalance
     */
    balance?: number;
}
/**
 * Request object to register(or delete) a new xpub
 * @export
 * @interface XpubRequest
 */
export interface XpubRequest {
    /**
     * The xpub to register.
     * @type {string}
     * @memberof XpubRequest
     */
    xpub?: string;
    /**
     * Skip transactions before this height. Default is 0. Ignore this while deleting xpub.
     * @type {number}
     * @memberof XpubRequest
     */
    skipHeight?: number;
    /**
     * Set the init maxReceiveIndex to {initReceiveIndex}(less than 5000) before the initial crawl , default is 200. This could increase cost.
     * @type {number}
     * @memberof XpubRequest
     */
    initReceiveIndex?: number;
    /**
     * Set the init maxChangeIndex(less than 5000) before the initial crawl , default is 200. This could increase cost.
     * @type {number}
     * @memberof XpubRequest
     */
    initChangeIndex?: number;
}
/**
 * XpubRegister result
 * @export
 * @interface XpubResult
 */
export interface XpubResult {
    /**
     * return xpub if broadcast success
     * @type {string}
     * @memberof XpubResult
     */
    xpub?: string;
    /**
     * return messages if broadcast failed
     * @type {string}
     * @memberof XpubResult
     */
    message?: string;
}
/**
 * Utxo belongs to the specified xpub
 * @export
 * @interface XpubUtxo
 */
export interface XpubUtxo {
    /**
     * xpub of the utxo
     * @type {string}
     * @memberof XpubUtxo
     */
    xpub?: string;
    /**
     * Address string of this utxo
     * @type {string}
     * @memberof XpubUtxo
     */
    address?: string;
    /**
     * Address type, 0 for receive address, 1 for change address. path is {{addressType}}/{{addressIndex}}
     * @type {number}
     * @memberof XpubUtxo
     */
    addressType?: number;
    /**
     * Address index. Address path in the xpub is {{addressType}}/{{addressIndex}}
     * @type {number}
     * @memberof XpubUtxo
     */
    addressIndex?: number;
    /**
     * Txid for this utxo.
     * @type {string}
     * @memberof XpubUtxo
     */
    txid?: string;
    /**
     * Output index for the Utxo.
     * @type {number}
     * @memberof XpubUtxo
     */
    txIndex?: number;
    /**
     * Satoshi value of the utxo.
     * @type {number}
     * @memberof XpubUtxo
     */
    value?: number;
    /**
     * The height of this utxo, -1 for unconfirmed utxo.
     * @type {number}
     * @memberof XpubUtxo
     */
    height?: number;
    /**
     * The paging flag of utxo
     * @type {number}
     * @memberof XpubUtxo
     */
    flag?: number;
}

/**
 * AddressApi - axios parameter creator
 * @export
 */
export const AddressApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get address balance by specific address.
         * @param {string} address the requested address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressAddressBalanceGet: async (address: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            if (address === null || address === undefined) {
                throw new RequiredError('address','Required parameter address was null or undefined when calling addressAddressBalanceGet.');
            }
            const localVarPath = `/address/{address}/balance`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get address history by specific address(recent 10 days available).
         * @param {string} address the requested address
         * @param {string} [flag] The last id of the last query(Paging flag)
         * @param {boolean} [confirmed] (default true) fetch confirmed tx, fetch unconfirmed tx if false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressAddressTxGet: async (address: string, flag?: string, confirmed?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            if (address === null || address === undefined) {
                throw new RequiredError('address','Required parameter address was null or undefined when calling addressAddressTxGet.');
            }
            const localVarPath = `/address/{address}/tx`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (flag !== undefined) {
                localVarQueryParameter['flag'] = flag;
            }

            if (confirmed !== undefined) {
                localVarQueryParameter['confirmed'] = confirmed;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get address utxos by specific address(100 per page).
         * @param {string} address the requested address
         * @param {string} [flag] The last id of the last query(Paging flag)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressAddressUtxoGet: async (address: string, flag?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            if (address === null || address === undefined) {
                throw new RequiredError('address','Required parameter address was null or undefined when calling addressAddressUtxoGet.');
            }
            const localVarPath = `/address/{address}/utxo`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (flag !== undefined) {
                localVarQueryParameter['flag'] = flag;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AddressApi - functional programming interface
 * @export
 */
export const AddressApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get address balance by specific address.
         * @param {string} address the requested address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addressAddressBalanceGet(address: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddressBalance>> {
            const localVarAxiosArgs = await AddressApiAxiosParamCreator(configuration).addressAddressBalanceGet(address, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get address history by specific address(recent 10 days available).
         * @param {string} address the requested address
         * @param {string} [flag] The last id of the last query(Paging flag)
         * @param {boolean} [confirmed] (default true) fetch confirmed tx, fetch unconfirmed tx if false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addressAddressTxGet(address: string, flag?: string, confirmed?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AddressTx>>> {
            const localVarAxiosArgs = await AddressApiAxiosParamCreator(configuration).addressAddressTxGet(address, flag, confirmed, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get address utxos by specific address(100 per page).
         * @param {string} address the requested address
         * @param {string} [flag] The last id of the last query(Paging flag)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addressAddressUtxoGet(address: string, flag?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AddressUtxo>>> {
            const localVarAxiosArgs = await AddressApiAxiosParamCreator(configuration).addressAddressUtxoGet(address, flag, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * AddressApi - factory interface
 * @export
 */
export const AddressApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Get address balance by specific address.
         * @param {string} address the requested address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressAddressBalanceGet(address: string, options?: any): AxiosPromise<AddressBalance> {
            return AddressApiFp(configuration).addressAddressBalanceGet(address, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get address history by specific address(recent 10 days available).
         * @param {string} address the requested address
         * @param {string} [flag] The last id of the last query(Paging flag)
         * @param {boolean} [confirmed] (default true) fetch confirmed tx, fetch unconfirmed tx if false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressAddressTxGet(address: string, flag?: string, confirmed?: boolean, options?: any): AxiosPromise<Array<AddressTx>> {
            return AddressApiFp(configuration).addressAddressTxGet(address, flag, confirmed, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get address utxos by specific address(100 per page).
         * @param {string} address the requested address
         * @param {string} [flag] The last id of the last query(Paging flag)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressAddressUtxoGet(address: string, flag?: string, options?: any): AxiosPromise<Array<AddressUtxo>> {
            return AddressApiFp(configuration).addressAddressUtxoGet(address, flag, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AddressApi - object-oriented interface
 * @export
 * @class AddressApi
 * @extends {BaseAPI}
 */
export class AddressApi extends BaseAPI {
    /**
     * 
     * @summary Get address balance by specific address.
     * @param {string} address the requested address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressApi
     */
    public addressAddressBalanceGet(address: string, options?: any) {
        return AddressApiFp(this.configuration).addressAddressBalanceGet(address, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get address history by specific address(recent 10 days available).
     * @param {string} address the requested address
     * @param {string} [flag] The last id of the last query(Paging flag)
     * @param {boolean} [confirmed] (default true) fetch confirmed tx, fetch unconfirmed tx if false
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressApi
     */
    public addressAddressTxGet(address: string, flag?: string, confirmed?: boolean, options?: any) {
        return AddressApiFp(this.configuration).addressAddressTxGet(address, flag, confirmed, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get address utxos by specific address(100 per page).
     * @param {string} address the requested address
     * @param {string} [flag] The last id of the last query(Paging flag)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressApi
     */
    public addressAddressUtxoGet(address: string, flag?: string, options?: any) {
        return AddressApiFp(this.configuration).addressAddressUtxoGet(address, flag, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * BlockApi - axios parameter creator
 * @export
 */
export const BlockApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get block request by height or hash
         * @param {string} blockId The block id, height or hash acceptable.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blockBlockIdGet: async (blockId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'blockId' is not null or undefined
            if (blockId === null || blockId === undefined) {
                throw new RequiredError('blockId','Required parameter blockId was null or undefined when calling blockBlockIdGet.');
            }
            const localVarPath = `/block/{blockId}`
                .replace(`{${"blockId"}}`, encodeURIComponent(String(blockId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get recent block list by paging. 30 items per page.
         * @param {number} [last] paging flag, height of last item in last page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blockGet: async (last?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/block`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (last !== undefined) {
                localVarQueryParameter['last'] = last;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get current blockchain info from full node.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blockInfoGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/block/info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BlockApi - functional programming interface
 * @export
 */
export const BlockApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get block request by height or hash
         * @param {string} blockId The block id, height or hash acceptable.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async blockBlockIdGet(blockId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BlockHeaderIndex>> {
            const localVarAxiosArgs = await BlockApiAxiosParamCreator(configuration).blockBlockIdGet(blockId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get recent block list by paging. 30 items per page.
         * @param {number} [last] paging flag, height of last item in last page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async blockGet(last?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BlockHeaderPage>>> {
            const localVarAxiosArgs = await BlockApiAxiosParamCreator(configuration).blockGet(last, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get current blockchain info from full node.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async blockInfoGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BlockchainInfo>> {
            const localVarAxiosArgs = await BlockApiAxiosParamCreator(configuration).blockInfoGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * BlockApi - factory interface
 * @export
 */
export const BlockApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Get block request by height or hash
         * @param {string} blockId The block id, height or hash acceptable.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blockBlockIdGet(blockId: string, options?: any): AxiosPromise<BlockHeaderIndex> {
            return BlockApiFp(configuration).blockBlockIdGet(blockId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get recent block list by paging. 30 items per page.
         * @param {number} [last] paging flag, height of last item in last page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blockGet(last?: number, options?: any): AxiosPromise<Array<BlockHeaderPage>> {
            return BlockApiFp(configuration).blockGet(last, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get current blockchain info from full node.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blockInfoGet(options?: any): AxiosPromise<BlockchainInfo> {
            return BlockApiFp(configuration).blockInfoGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BlockApi - object-oriented interface
 * @export
 * @class BlockApi
 * @extends {BaseAPI}
 */
export class BlockApi extends BaseAPI {
    /**
     * 
     * @summary Get block request by height or hash
     * @param {string} blockId The block id, height or hash acceptable.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlockApi
     */
    public blockBlockIdGet(blockId: string, options?: any) {
        return BlockApiFp(this.configuration).blockBlockIdGet(blockId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get recent block list by paging. 30 items per page.
     * @param {number} [last] paging flag, height of last item in last page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlockApi
     */
    public blockGet(last?: number, options?: any) {
        return BlockApiFp(this.configuration).blockGet(last, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get current blockchain info from full node.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlockApi
     */
    public blockInfoGet(options?: any) {
        return BlockApiFp(this.configuration).blockInfoGet(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ContractApi - axios parameter creator
 * @export
 */
export const ContractApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get all contract token balances for specific address ignoring all unconfirmed txs.
         * @param {string} address the requested address
         * @param {string} codeHash Filter by contract code hash
         * @param {string} genesis Filter by contract genesis
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractFtAddressAddressBalanceConfirmedGet: async (address: string, codeHash: string, genesis: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            if (address === null || address === undefined) {
                throw new RequiredError('address','Required parameter address was null or undefined when calling contractFtAddressAddressBalanceConfirmedGet.');
            }
            // verify required parameter 'codeHash' is not null or undefined
            if (codeHash === null || codeHash === undefined) {
                throw new RequiredError('codeHash','Required parameter codeHash was null or undefined when calling contractFtAddressAddressBalanceConfirmedGet.');
            }
            // verify required parameter 'genesis' is not null or undefined
            if (genesis === null || genesis === undefined) {
                throw new RequiredError('genesis','Required parameter genesis was null or undefined when calling contractFtAddressAddressBalanceConfirmedGet.');
            }
            const localVarPath = `/contract/ft/address/{address}/balance/confirmed`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (codeHash !== undefined) {
                localVarQueryParameter['codeHash'] = codeHash;
            }

            if (genesis !== undefined) {
                localVarQueryParameter['genesis'] = genesis;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all contract token balances for specific address.
         * @param {string} address the requested address
         * @param {string} [codeHash] Filter by contract code hash
         * @param {string} [genesis] Filter by contract genesis
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractFtAddressAddressBalanceGet: async (address: string, codeHash?: string, genesis?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            if (address === null || address === undefined) {
                throw new RequiredError('address','Required parameter address was null or undefined when calling contractFtAddressAddressBalanceGet.');
            }
            const localVarPath = `/contract/ft/address/{address}/balance`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (codeHash !== undefined) {
                localVarQueryParameter['codeHash'] = codeHash;
            }

            if (genesis !== undefined) {
                localVarQueryParameter['genesis'] = genesis;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all contract token balances for specific address.
         * @param {string} address the requested address
         * @param {string} codeHash Filter by contract code hash
         * @param {string} genesis Filter by contract genesis
         * @param {string} [flag] The last id of the last query(Paging flag)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractFtAddressAddressCodeHashGenesisTxGet: async (address: string, codeHash: string, genesis: string, flag?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            if (address === null || address === undefined) {
                throw new RequiredError('address','Required parameter address was null or undefined when calling contractFtAddressAddressCodeHashGenesisTxGet.');
            }
            // verify required parameter 'codeHash' is not null or undefined
            if (codeHash === null || codeHash === undefined) {
                throw new RequiredError('codeHash','Required parameter codeHash was null or undefined when calling contractFtAddressAddressCodeHashGenesisTxGet.');
            }
            // verify required parameter 'genesis' is not null or undefined
            if (genesis === null || genesis === undefined) {
                throw new RequiredError('genesis','Required parameter genesis was null or undefined when calling contractFtAddressAddressCodeHashGenesisTxGet.');
            }
            const localVarPath = `/contract/ft/address/{address}/{codeHash}/{genesis}/tx`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)))
                .replace(`{${"codeHash"}}`, encodeURIComponent(String(codeHash)))
                .replace(`{${"genesis"}}`, encodeURIComponent(String(genesis)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (flag !== undefined) {
                localVarQueryParameter['flag'] = flag;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all contract token utxos for specific address.
         * @param {string} address the requested address
         * @param {string} [codeHash] Filter by contract code hash
         * @param {string} [genesis] Filter by contract genesis
         * @param {string} [flag] The flag of the last query Item(Paging flag)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractFtAddressAddressUtxoGet: async (address: string, codeHash?: string, genesis?: string, flag?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            if (address === null || address === undefined) {
                throw new RequiredError('address','Required parameter address was null or undefined when calling contractFtAddressAddressUtxoGet.');
            }
            const localVarPath = `/contract/ft/address/{address}/utxo`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (codeHash !== undefined) {
                localVarQueryParameter['codeHash'] = codeHash;
            }

            if (genesis !== undefined) {
                localVarQueryParameter['genesis'] = genesis;
            }

            if (flag !== undefined) {
                localVarQueryParameter['flag'] = flag;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all sum of circulation ft token utxos by codeHash and genesisId(10min cached).
         * @param {string} codeHash Code hash of the token.
         * @param {string} genesis Contract genesis
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractFtGenesisCodeHashGenesisCirculationGet: async (codeHash: string, genesis: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'codeHash' is not null or undefined
            if (codeHash === null || codeHash === undefined) {
                throw new RequiredError('codeHash','Required parameter codeHash was null or undefined when calling contractFtGenesisCodeHashGenesisCirculationGet.');
            }
            // verify required parameter 'genesis' is not null or undefined
            if (genesis === null || genesis === undefined) {
                throw new RequiredError('genesis','Required parameter genesis was null or undefined when calling contractFtGenesisCodeHashGenesisCirculationGet.');
            }
            const localVarPath = `/contract/ft/genesis/{codeHash}/{genesis}/circulation`
                .replace(`{${"codeHash"}}`, encodeURIComponent(String(codeHash)))
                .replace(`{${"genesis"}}`, encodeURIComponent(String(genesis)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get confirmed utxo count for specific nft(ignore all unconfirmed txs).
         * @param {string} address the requested address
         * @param {string} codeHash Filter by contract code hash
         * @param {string} genesis Filter by contract genesis
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractNftAddressAddressCountConfirmedGet: async (address: string, codeHash: string, genesis: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            if (address === null || address === undefined) {
                throw new RequiredError('address','Required parameter address was null or undefined when calling contractNftAddressAddressCountConfirmedGet.');
            }
            // verify required parameter 'codeHash' is not null or undefined
            if (codeHash === null || codeHash === undefined) {
                throw new RequiredError('codeHash','Required parameter codeHash was null or undefined when calling contractNftAddressAddressCountConfirmedGet.');
            }
            // verify required parameter 'genesis' is not null or undefined
            if (genesis === null || genesis === undefined) {
                throw new RequiredError('genesis','Required parameter genesis was null or undefined when calling contractNftAddressAddressCountConfirmedGet.');
            }
            const localVarPath = `/contract/nft/address/{address}/count/confirmed`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (codeHash !== undefined) {
                localVarQueryParameter['codeHash'] = codeHash;
            }

            if (genesis !== undefined) {
                localVarQueryParameter['genesis'] = genesis;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get nft summary(NFT count group by genesis) for address.
         * @param {string} address the requested address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractNftAddressAddressSummaryGet: async (address: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            if (address === null || address === undefined) {
                throw new RequiredError('address','Required parameter address was null or undefined when calling contractNftAddressAddressSummaryGet.');
            }
            const localVarPath = `/contract/nft/address/{address}/summary`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all contract nft token utxos for specific address.
         * @param {string} address the requested address
         * @param {string} [codeHash] Filter by contract code hash
         * @param {string} [genesis] Filter by contract genesis
         * @param {number} [limit] Limit the return count(no more than 300)
         * @param {string} [flag] The flag of the last query Item(Paging flag)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractNftAddressAddressUtxoGet: async (address: string, codeHash?: string, genesis?: string, limit?: number, flag?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            if (address === null || address === undefined) {
                throw new RequiredError('address','Required parameter address was null or undefined when calling contractNftAddressAddressUtxoGet.');
            }
            const localVarPath = `/contract/nft/address/{address}/utxo`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (codeHash !== undefined) {
                localVarQueryParameter['codeHash'] = codeHash;
            }

            if (genesis !== undefined) {
                localVarQueryParameter['genesis'] = genesis;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (flag !== undefined) {
                localVarQueryParameter['flag'] = flag;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get nft summary(count group by address) for specific codeHash and genesisId(result cached for 60s).
         * @param {string} codeHash Code hash of the token.
         * @param {string} genesis Contract genesis
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractNftGenesisCodeHashGenesisSummaryGet: async (codeHash: string, genesis: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'codeHash' is not null or undefined
            if (codeHash === null || codeHash === undefined) {
                throw new RequiredError('codeHash','Required parameter codeHash was null or undefined when calling contractNftGenesisCodeHashGenesisSummaryGet.');
            }
            // verify required parameter 'genesis' is not null or undefined
            if (genesis === null || genesis === undefined) {
                throw new RequiredError('genesis','Required parameter genesis was null or undefined when calling contractNftGenesisCodeHashGenesisSummaryGet.');
            }
            const localVarPath = `/contract/nft/genesis/{codeHash}/{genesis}/summary`
                .replace(`{${"codeHash"}}`, encodeURIComponent(String(codeHash)))
                .replace(`{${"genesis"}}`, encodeURIComponent(String(genesis)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all contract nft token utxos by codeHash and genesisId.
         * @param {string} codeHash Code hash of the token.
         * @param {string} genesis Contract genesis
         * @param {number} [tokenIndex] Find exact token Index.
         * @param {number} [max] Token index not bigger than this(include this).
         * @param {number} [min] Token index not less than this(include this).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractNftGenesisCodeHashGenesisUtxoGet: async (codeHash: string, genesis: string, tokenIndex?: number, max?: number, min?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'codeHash' is not null or undefined
            if (codeHash === null || codeHash === undefined) {
                throw new RequiredError('codeHash','Required parameter codeHash was null or undefined when calling contractNftGenesisCodeHashGenesisUtxoGet.');
            }
            // verify required parameter 'genesis' is not null or undefined
            if (genesis === null || genesis === undefined) {
                throw new RequiredError('genesis','Required parameter genesis was null or undefined when calling contractNftGenesisCodeHashGenesisUtxoGet.');
            }
            const localVarPath = `/contract/nft/genesis/{codeHash}/{genesis}/utxo`
                .replace(`{${"codeHash"}}`, encodeURIComponent(String(codeHash)))
                .replace(`{${"genesis"}}`, encodeURIComponent(String(genesis)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (tokenIndex !== undefined) {
                localVarQueryParameter['tokenIndex'] = tokenIndex;
            }

            if (max !== undefined) {
                localVarQueryParameter['max'] = max;
            }

            if (min !== undefined) {
                localVarQueryParameter['min'] = min;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all contract sell sell utxos for specific address.
         * @param {string} address Owner address.
         * @param {string} [codeHash] Filter by contract code hash
         * @param {string} [genesis] Filter by contract genesis
         * @param {string} [flag] The flag of the last query Item(Paging flag)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractNftSellAddressAddressUtxoGet: async (address: string, codeHash?: string, genesis?: string, flag?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            if (address === null || address === undefined) {
                throw new RequiredError('address','Required parameter address was null or undefined when calling contractNftSellAddressAddressUtxoGet.');
            }
            const localVarPath = `/contract/nft/sell/address/{address}/utxo`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (codeHash !== undefined) {
                localVarQueryParameter['codeHash'] = codeHash;
            }

            if (genesis !== undefined) {
                localVarQueryParameter['genesis'] = genesis;
            }

            if (flag !== undefined) {
                localVarQueryParameter['flag'] = flag;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all contract nft token utxos by codeHash and genesisId.
         * @param {string} codeHash Code hash of the token.
         * @param {string} genesis Contract genesis
         * @param {number} [tokenIndex] Find exact token Index.
         * @param {number} [max] Token index not bigger than this(include this).
         * @param {number} [min] Token index not less than this(include this).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractNftSellGenesisCodeHashGenesisUtxoGet: async (codeHash: string, genesis: string, tokenIndex?: number, max?: number, min?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'codeHash' is not null or undefined
            if (codeHash === null || codeHash === undefined) {
                throw new RequiredError('codeHash','Required parameter codeHash was null or undefined when calling contractNftSellGenesisCodeHashGenesisUtxoGet.');
            }
            // verify required parameter 'genesis' is not null or undefined
            if (genesis === null || genesis === undefined) {
                throw new RequiredError('genesis','Required parameter genesis was null or undefined when calling contractNftSellGenesisCodeHashGenesisUtxoGet.');
            }
            const localVarPath = `/contract/nft/sell/genesis/{codeHash}/{genesis}/utxo`
                .replace(`{${"codeHash"}}`, encodeURIComponent(String(codeHash)))
                .replace(`{${"genesis"}}`, encodeURIComponent(String(genesis)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (tokenIndex !== undefined) {
                localVarQueryParameter['tokenIndex'] = tokenIndex;
            }

            if (max !== undefined) {
                localVarQueryParameter['max'] = max;
            }

            if (min !== undefined) {
                localVarQueryParameter['min'] = min;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get contract unique utxos by codeHash and genesisId.
         * @param {string} codeHash Code hash of the token.
         * @param {string} genesis Contract genesis
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractUniqueGenesisCodeHashGenesisUtxoGet: async (codeHash: string, genesis: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'codeHash' is not null or undefined
            if (codeHash === null || codeHash === undefined) {
                throw new RequiredError('codeHash','Required parameter codeHash was null or undefined when calling contractUniqueGenesisCodeHashGenesisUtxoGet.');
            }
            // verify required parameter 'genesis' is not null or undefined
            if (genesis === null || genesis === undefined) {
                throw new RequiredError('genesis','Required parameter genesis was null or undefined when calling contractUniqueGenesisCodeHashGenesisUtxoGet.');
            }
            const localVarPath = `/contract/unique/genesis/{codeHash}/{genesis}/utxo`
                .replace(`{${"codeHash"}}`, encodeURIComponent(String(codeHash)))
                .replace(`{${"genesis"}}`, encodeURIComponent(String(genesis)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContractApi - functional programming interface
 * @export
 */
export const ContractApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get all contract token balances for specific address ignoring all unconfirmed txs.
         * @param {string} address the requested address
         * @param {string} codeHash Filter by contract code hash
         * @param {string} genesis Filter by contract genesis
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contractFtAddressAddressBalanceConfirmedGet(address: string, codeHash: string, genesis: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await ContractApiAxiosParamCreator(configuration).contractFtAddressAddressBalanceConfirmedGet(address, codeHash, genesis, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get all contract token balances for specific address.
         * @param {string} address the requested address
         * @param {string} [codeHash] Filter by contract code hash
         * @param {string} [genesis] Filter by contract genesis
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contractFtAddressAddressBalanceGet(address: string, codeHash?: string, genesis?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ContractFtBalance>>> {
            const localVarAxiosArgs = await ContractApiAxiosParamCreator(configuration).contractFtAddressAddressBalanceGet(address, codeHash, genesis, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get all contract token balances for specific address.
         * @param {string} address the requested address
         * @param {string} codeHash Filter by contract code hash
         * @param {string} genesis Filter by contract genesis
         * @param {string} [flag] The last id of the last query(Paging flag)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contractFtAddressAddressCodeHashGenesisTxGet(address: string, codeHash: string, genesis: string, flag?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ContractFtAddressTx>>> {
            const localVarAxiosArgs = await ContractApiAxiosParamCreator(configuration).contractFtAddressAddressCodeHashGenesisTxGet(address, codeHash, genesis, flag, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get all contract token utxos for specific address.
         * @param {string} address the requested address
         * @param {string} [codeHash] Filter by contract code hash
         * @param {string} [genesis] Filter by contract genesis
         * @param {string} [flag] The flag of the last query Item(Paging flag)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contractFtAddressAddressUtxoGet(address: string, codeHash?: string, genesis?: string, flag?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ContractFtUtxo>>> {
            const localVarAxiosArgs = await ContractApiAxiosParamCreator(configuration).contractFtAddressAddressUtxoGet(address, codeHash, genesis, flag, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get all sum of circulation ft token utxos by codeHash and genesisId(10min cached).
         * @param {string} codeHash Code hash of the token.
         * @param {string} genesis Contract genesis
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contractFtGenesisCodeHashGenesisCirculationGet(codeHash: string, genesis: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContractFtGenesisCirculation>> {
            const localVarAxiosArgs = await ContractApiAxiosParamCreator(configuration).contractFtGenesisCodeHashGenesisCirculationGet(codeHash, genesis, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get confirmed utxo count for specific nft(ignore all unconfirmed txs).
         * @param {string} address the requested address
         * @param {string} codeHash Filter by contract code hash
         * @param {string} genesis Filter by contract genesis
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contractNftAddressAddressCountConfirmedGet(address: string, codeHash: string, genesis: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await ContractApiAxiosParamCreator(configuration).contractNftAddressAddressCountConfirmedGet(address, codeHash, genesis, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get nft summary(NFT count group by genesis) for address.
         * @param {string} address the requested address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contractNftAddressAddressSummaryGet(address: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ContractNftAddressSummary>>> {
            const localVarAxiosArgs = await ContractApiAxiosParamCreator(configuration).contractNftAddressAddressSummaryGet(address, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get all contract nft token utxos for specific address.
         * @param {string} address the requested address
         * @param {string} [codeHash] Filter by contract code hash
         * @param {string} [genesis] Filter by contract genesis
         * @param {number} [limit] Limit the return count(no more than 300)
         * @param {string} [flag] The flag of the last query Item(Paging flag)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contractNftAddressAddressUtxoGet(address: string, codeHash?: string, genesis?: string, limit?: number, flag?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ContractNftUtxo>>> {
            const localVarAxiosArgs = await ContractApiAxiosParamCreator(configuration).contractNftAddressAddressUtxoGet(address, codeHash, genesis, limit, flag, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get nft summary(count group by address) for specific codeHash and genesisId(result cached for 60s).
         * @param {string} codeHash Code hash of the token.
         * @param {string} genesis Contract genesis
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contractNftGenesisCodeHashGenesisSummaryGet(codeHash: string, genesis: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ContractNftGenesisSummary>>> {
            const localVarAxiosArgs = await ContractApiAxiosParamCreator(configuration).contractNftGenesisCodeHashGenesisSummaryGet(codeHash, genesis, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get all contract nft token utxos by codeHash and genesisId.
         * @param {string} codeHash Code hash of the token.
         * @param {string} genesis Contract genesis
         * @param {number} [tokenIndex] Find exact token Index.
         * @param {number} [max] Token index not bigger than this(include this).
         * @param {number} [min] Token index not less than this(include this).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contractNftGenesisCodeHashGenesisUtxoGet(codeHash: string, genesis: string, tokenIndex?: number, max?: number, min?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ContractNftUtxo>>> {
            const localVarAxiosArgs = await ContractApiAxiosParamCreator(configuration).contractNftGenesisCodeHashGenesisUtxoGet(codeHash, genesis, tokenIndex, max, min, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get all contract sell sell utxos for specific address.
         * @param {string} address Owner address.
         * @param {string} [codeHash] Filter by contract code hash
         * @param {string} [genesis] Filter by contract genesis
         * @param {string} [flag] The flag of the last query Item(Paging flag)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contractNftSellAddressAddressUtxoGet(address: string, codeHash?: string, genesis?: string, flag?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ContractNftSellUtxo>>> {
            const localVarAxiosArgs = await ContractApiAxiosParamCreator(configuration).contractNftSellAddressAddressUtxoGet(address, codeHash, genesis, flag, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get all contract nft token utxos by codeHash and genesisId.
         * @param {string} codeHash Code hash of the token.
         * @param {string} genesis Contract genesis
         * @param {number} [tokenIndex] Find exact token Index.
         * @param {number} [max] Token index not bigger than this(include this).
         * @param {number} [min] Token index not less than this(include this).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contractNftSellGenesisCodeHashGenesisUtxoGet(codeHash: string, genesis: string, tokenIndex?: number, max?: number, min?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ContractNftSellUtxo>>> {
            const localVarAxiosArgs = await ContractApiAxiosParamCreator(configuration).contractNftSellGenesisCodeHashGenesisUtxoGet(codeHash, genesis, tokenIndex, max, min, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get contract unique utxos by codeHash and genesisId.
         * @param {string} codeHash Code hash of the token.
         * @param {string} genesis Contract genesis
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contractUniqueGenesisCodeHashGenesisUtxoGet(codeHash: string, genesis: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ContractUniqueUtxo>>> {
            const localVarAxiosArgs = await ContractApiAxiosParamCreator(configuration).contractUniqueGenesisCodeHashGenesisUtxoGet(codeHash, genesis, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ContractApi - factory interface
 * @export
 */
export const ContractApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Get all contract token balances for specific address ignoring all unconfirmed txs.
         * @param {string} address the requested address
         * @param {string} codeHash Filter by contract code hash
         * @param {string} genesis Filter by contract genesis
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractFtAddressAddressBalanceConfirmedGet(address: string, codeHash: string, genesis: string, options?: any): AxiosPromise<number> {
            return ContractApiFp(configuration).contractFtAddressAddressBalanceConfirmedGet(address, codeHash, genesis, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all contract token balances for specific address.
         * @param {string} address the requested address
         * @param {string} [codeHash] Filter by contract code hash
         * @param {string} [genesis] Filter by contract genesis
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractFtAddressAddressBalanceGet(address: string, codeHash?: string, genesis?: string, options?: any): AxiosPromise<Array<ContractFtBalance>> {
            return ContractApiFp(configuration).contractFtAddressAddressBalanceGet(address, codeHash, genesis, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all contract token balances for specific address.
         * @param {string} address the requested address
         * @param {string} codeHash Filter by contract code hash
         * @param {string} genesis Filter by contract genesis
         * @param {string} [flag] The last id of the last query(Paging flag)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractFtAddressAddressCodeHashGenesisTxGet(address: string, codeHash: string, genesis: string, flag?: string, options?: any): AxiosPromise<Array<ContractFtAddressTx>> {
            return ContractApiFp(configuration).contractFtAddressAddressCodeHashGenesisTxGet(address, codeHash, genesis, flag, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all contract token utxos for specific address.
         * @param {string} address the requested address
         * @param {string} [codeHash] Filter by contract code hash
         * @param {string} [genesis] Filter by contract genesis
         * @param {string} [flag] The flag of the last query Item(Paging flag)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractFtAddressAddressUtxoGet(address: string, codeHash?: string, genesis?: string, flag?: string, options?: any): AxiosPromise<Array<ContractFtUtxo>> {
            return ContractApiFp(configuration).contractFtAddressAddressUtxoGet(address, codeHash, genesis, flag, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all sum of circulation ft token utxos by codeHash and genesisId(10min cached).
         * @param {string} codeHash Code hash of the token.
         * @param {string} genesis Contract genesis
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractFtGenesisCodeHashGenesisCirculationGet(codeHash: string, genesis: string, options?: any): AxiosPromise<ContractFtGenesisCirculation> {
            return ContractApiFp(configuration).contractFtGenesisCodeHashGenesisCirculationGet(codeHash, genesis, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get confirmed utxo count for specific nft(ignore all unconfirmed txs).
         * @param {string} address the requested address
         * @param {string} codeHash Filter by contract code hash
         * @param {string} genesis Filter by contract genesis
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractNftAddressAddressCountConfirmedGet(address: string, codeHash: string, genesis: string, options?: any): AxiosPromise<number> {
            return ContractApiFp(configuration).contractNftAddressAddressCountConfirmedGet(address, codeHash, genesis, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get nft summary(NFT count group by genesis) for address.
         * @param {string} address the requested address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractNftAddressAddressSummaryGet(address: string, options?: any): AxiosPromise<Array<ContractNftAddressSummary>> {
            return ContractApiFp(configuration).contractNftAddressAddressSummaryGet(address, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all contract nft token utxos for specific address.
         * @param {string} address the requested address
         * @param {string} [codeHash] Filter by contract code hash
         * @param {string} [genesis] Filter by contract genesis
         * @param {number} [limit] Limit the return count(no more than 300)
         * @param {string} [flag] The flag of the last query Item(Paging flag)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractNftAddressAddressUtxoGet(address: string, codeHash?: string, genesis?: string, limit?: number, flag?: string, options?: any): AxiosPromise<Array<ContractNftUtxo>> {
            return ContractApiFp(configuration).contractNftAddressAddressUtxoGet(address, codeHash, genesis, limit, flag, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get nft summary(count group by address) for specific codeHash and genesisId(result cached for 60s).
         * @param {string} codeHash Code hash of the token.
         * @param {string} genesis Contract genesis
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractNftGenesisCodeHashGenesisSummaryGet(codeHash: string, genesis: string, options?: any): AxiosPromise<Array<ContractNftGenesisSummary>> {
            return ContractApiFp(configuration).contractNftGenesisCodeHashGenesisSummaryGet(codeHash, genesis, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all contract nft token utxos by codeHash and genesisId.
         * @param {string} codeHash Code hash of the token.
         * @param {string} genesis Contract genesis
         * @param {number} [tokenIndex] Find exact token Index.
         * @param {number} [max] Token index not bigger than this(include this).
         * @param {number} [min] Token index not less than this(include this).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractNftGenesisCodeHashGenesisUtxoGet(codeHash: string, genesis: string, tokenIndex?: number, max?: number, min?: number, options?: any): AxiosPromise<Array<ContractNftUtxo>> {
            return ContractApiFp(configuration).contractNftGenesisCodeHashGenesisUtxoGet(codeHash, genesis, tokenIndex, max, min, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all contract sell sell utxos for specific address.
         * @param {string} address Owner address.
         * @param {string} [codeHash] Filter by contract code hash
         * @param {string} [genesis] Filter by contract genesis
         * @param {string} [flag] The flag of the last query Item(Paging flag)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractNftSellAddressAddressUtxoGet(address: string, codeHash?: string, genesis?: string, flag?: string, options?: any): AxiosPromise<Array<ContractNftSellUtxo>> {
            return ContractApiFp(configuration).contractNftSellAddressAddressUtxoGet(address, codeHash, genesis, flag, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all contract nft token utxos by codeHash and genesisId.
         * @param {string} codeHash Code hash of the token.
         * @param {string} genesis Contract genesis
         * @param {number} [tokenIndex] Find exact token Index.
         * @param {number} [max] Token index not bigger than this(include this).
         * @param {number} [min] Token index not less than this(include this).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractNftSellGenesisCodeHashGenesisUtxoGet(codeHash: string, genesis: string, tokenIndex?: number, max?: number, min?: number, options?: any): AxiosPromise<Array<ContractNftSellUtxo>> {
            return ContractApiFp(configuration).contractNftSellGenesisCodeHashGenesisUtxoGet(codeHash, genesis, tokenIndex, max, min, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get contract unique utxos by codeHash and genesisId.
         * @param {string} codeHash Code hash of the token.
         * @param {string} genesis Contract genesis
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractUniqueGenesisCodeHashGenesisUtxoGet(codeHash: string, genesis: string, options?: any): AxiosPromise<Array<ContractUniqueUtxo>> {
            return ContractApiFp(configuration).contractUniqueGenesisCodeHashGenesisUtxoGet(codeHash, genesis, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContractApi - object-oriented interface
 * @export
 * @class ContractApi
 * @extends {BaseAPI}
 */
export class ContractApi extends BaseAPI {
    /**
     * 
     * @summary Get all contract token balances for specific address ignoring all unconfirmed txs.
     * @param {string} address the requested address
     * @param {string} codeHash Filter by contract code hash
     * @param {string} genesis Filter by contract genesis
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractApi
     */
    public contractFtAddressAddressBalanceConfirmedGet(address: string, codeHash: string, genesis: string, options?: any) {
        return ContractApiFp(this.configuration).contractFtAddressAddressBalanceConfirmedGet(address, codeHash, genesis, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all contract token balances for specific address.
     * @param {string} address the requested address
     * @param {string} [codeHash] Filter by contract code hash
     * @param {string} [genesis] Filter by contract genesis
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractApi
     */
    public contractFtAddressAddressBalanceGet(address: string, codeHash?: string, genesis?: string, options?: any) {
        return ContractApiFp(this.configuration).contractFtAddressAddressBalanceGet(address, codeHash, genesis, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all contract token balances for specific address.
     * @param {string} address the requested address
     * @param {string} codeHash Filter by contract code hash
     * @param {string} genesis Filter by contract genesis
     * @param {string} [flag] The last id of the last query(Paging flag)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractApi
     */
    public contractFtAddressAddressCodeHashGenesisTxGet(address: string, codeHash: string, genesis: string, flag?: string, options?: any) {
        return ContractApiFp(this.configuration).contractFtAddressAddressCodeHashGenesisTxGet(address, codeHash, genesis, flag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all contract token utxos for specific address.
     * @param {string} address the requested address
     * @param {string} [codeHash] Filter by contract code hash
     * @param {string} [genesis] Filter by contract genesis
     * @param {string} [flag] The flag of the last query Item(Paging flag)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractApi
     */
    public contractFtAddressAddressUtxoGet(address: string, codeHash?: string, genesis?: string, flag?: string, options?: any) {
        return ContractApiFp(this.configuration).contractFtAddressAddressUtxoGet(address, codeHash, genesis, flag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all sum of circulation ft token utxos by codeHash and genesisId(10min cached).
     * @param {string} codeHash Code hash of the token.
     * @param {string} genesis Contract genesis
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractApi
     */
    public contractFtGenesisCodeHashGenesisCirculationGet(codeHash: string, genesis: string, options?: any) {
        return ContractApiFp(this.configuration).contractFtGenesisCodeHashGenesisCirculationGet(codeHash, genesis, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get confirmed utxo count for specific nft(ignore all unconfirmed txs).
     * @param {string} address the requested address
     * @param {string} codeHash Filter by contract code hash
     * @param {string} genesis Filter by contract genesis
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractApi
     */
    public contractNftAddressAddressCountConfirmedGet(address: string, codeHash: string, genesis: string, options?: any) {
        return ContractApiFp(this.configuration).contractNftAddressAddressCountConfirmedGet(address, codeHash, genesis, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get nft summary(NFT count group by genesis) for address.
     * @param {string} address the requested address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractApi
     */
    public contractNftAddressAddressSummaryGet(address: string, options?: any) {
        return ContractApiFp(this.configuration).contractNftAddressAddressSummaryGet(address, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all contract nft token utxos for specific address.
     * @param {string} address the requested address
     * @param {string} [codeHash] Filter by contract code hash
     * @param {string} [genesis] Filter by contract genesis
     * @param {number} [limit] Limit the return count(no more than 300)
     * @param {string} [flag] The flag of the last query Item(Paging flag)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractApi
     */
    public contractNftAddressAddressUtxoGet(address: string, codeHash?: string, genesis?: string, limit?: number, flag?: string, options?: any) {
        return ContractApiFp(this.configuration).contractNftAddressAddressUtxoGet(address, codeHash, genesis, limit, flag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get nft summary(count group by address) for specific codeHash and genesisId(result cached for 60s).
     * @param {string} codeHash Code hash of the token.
     * @param {string} genesis Contract genesis
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractApi
     */
    public contractNftGenesisCodeHashGenesisSummaryGet(codeHash: string, genesis: string, options?: any) {
        return ContractApiFp(this.configuration).contractNftGenesisCodeHashGenesisSummaryGet(codeHash, genesis, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all contract nft token utxos by codeHash and genesisId.
     * @param {string} codeHash Code hash of the token.
     * @param {string} genesis Contract genesis
     * @param {number} [tokenIndex] Find exact token Index.
     * @param {number} [max] Token index not bigger than this(include this).
     * @param {number} [min] Token index not less than this(include this).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractApi
     */
    public contractNftGenesisCodeHashGenesisUtxoGet(codeHash: string, genesis: string, tokenIndex?: number, max?: number, min?: number, options?: any) {
        return ContractApiFp(this.configuration).contractNftGenesisCodeHashGenesisUtxoGet(codeHash, genesis, tokenIndex, max, min, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all contract sell sell utxos for specific address.
     * @param {string} address Owner address.
     * @param {string} [codeHash] Filter by contract code hash
     * @param {string} [genesis] Filter by contract genesis
     * @param {string} [flag] The flag of the last query Item(Paging flag)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractApi
     */
    public contractNftSellAddressAddressUtxoGet(address: string, codeHash?: string, genesis?: string, flag?: string, options?: any) {
        return ContractApiFp(this.configuration).contractNftSellAddressAddressUtxoGet(address, codeHash, genesis, flag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all contract nft token utxos by codeHash and genesisId.
     * @param {string} codeHash Code hash of the token.
     * @param {string} genesis Contract genesis
     * @param {number} [tokenIndex] Find exact token Index.
     * @param {number} [max] Token index not bigger than this(include this).
     * @param {number} [min] Token index not less than this(include this).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractApi
     */
    public contractNftSellGenesisCodeHashGenesisUtxoGet(codeHash: string, genesis: string, tokenIndex?: number, max?: number, min?: number, options?: any) {
        return ContractApiFp(this.configuration).contractNftSellGenesisCodeHashGenesisUtxoGet(codeHash, genesis, tokenIndex, max, min, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get contract unique utxos by codeHash and genesisId.
     * @param {string} codeHash Code hash of the token.
     * @param {string} genesis Contract genesis
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractApi
     */
    public contractUniqueGenesisCodeHashGenesisUtxoGet(codeHash: string, genesis: string, options?: any) {
        return ContractApiFp(this.configuration).contractUniqueGenesisCodeHashGenesisUtxoGet(codeHash, genesis, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MerchantApi - axios parameter creator
 * @export
 */
export const MerchantApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Selects a set of Utxos with total value higher than the given amount from a given address list . In case of HD wallets, multiple addresses can be specified.
         * @summary Pick utxos by addresses and amount.
         * @param {UtxoPickRequest} [utxoPickRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        merchantUtxoPost: async (utxoPickRequest?: UtxoPickRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/merchant/utxo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof utxoPickRequest !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(utxoPickRequest !== undefined ? utxoPickRequest : {})
                : (utxoPickRequest || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MerchantApi - functional programming interface
 * @export
 */
export const MerchantApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Selects a set of Utxos with total value higher than the given amount from a given address list . In case of HD wallets, multiple addresses can be specified.
         * @summary Pick utxos by addresses and amount.
         * @param {UtxoPickRequest} [utxoPickRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async merchantUtxoPost(utxoPickRequest?: UtxoPickRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AddressUtxo>>> {
            const localVarAxiosArgs = await MerchantApiAxiosParamCreator(configuration).merchantUtxoPost(utxoPickRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * MerchantApi - factory interface
 * @export
 */
export const MerchantApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Selects a set of Utxos with total value higher than the given amount from a given address list . In case of HD wallets, multiple addresses can be specified.
         * @summary Pick utxos by addresses and amount.
         * @param {UtxoPickRequest} [utxoPickRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        merchantUtxoPost(utxoPickRequest?: UtxoPickRequest, options?: any): AxiosPromise<Array<AddressUtxo>> {
            return MerchantApiFp(configuration).merchantUtxoPost(utxoPickRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MerchantApi - object-oriented interface
 * @export
 * @class MerchantApi
 * @extends {BaseAPI}
 */
export class MerchantApi extends BaseAPI {
    /**
     * Selects a set of Utxos with total value higher than the given amount from a given address list . In case of HD wallets, multiple addresses can be specified.
     * @summary Pick utxos by addresses and amount.
     * @param {UtxoPickRequest} [utxoPickRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MerchantApi
     */
    public merchantUtxoPost(utxoPickRequest?: UtxoPickRequest, options?: any) {
        return MerchantApiFp(this.configuration).merchantUtxoPost(utxoPickRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * OutpointApi - axios parameter creator
 * @export
 */
export const OutpointApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get detailed info for a utxo(or txo if spent), Only outputs spent no longer than one month are available. (Premium feature will support full history)
         * @summary Get tx output(outpoint for vin) spent status.
         * @param {string} txid The txid of the output
         * @param {number} index The index of the output in the tx.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        outpointTxidIndexGet: async (txid: string, index: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'txid' is not null or undefined
            if (txid === null || txid === undefined) {
                throw new RequiredError('txid','Required parameter txid was null or undefined when calling outpointTxidIndexGet.');
            }
            // verify required parameter 'index' is not null or undefined
            if (index === null || index === undefined) {
                throw new RequiredError('index','Required parameter index was null or undefined when calling outpointTxidIndexGet.');
            }
            const localVarPath = `/outpoint/{txid}/{index}`
                .replace(`{${"txid"}}`, encodeURIComponent(String(txid)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OutpointApi - functional programming interface
 * @export
 */
export const OutpointApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get detailed info for a utxo(or txo if spent), Only outputs spent no longer than one month are available. (Premium feature will support full history)
         * @summary Get tx output(outpoint for vin) spent status.
         * @param {string} txid The txid of the output
         * @param {number} index The index of the output in the tx.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async outpointTxidIndexGet(txid: string, index: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OutputInfo>> {
            const localVarAxiosArgs = await OutpointApiAxiosParamCreator(configuration).outpointTxidIndexGet(txid, index, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * OutpointApi - factory interface
 * @export
 */
export const OutpointApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Get detailed info for a utxo(or txo if spent), Only outputs spent no longer than one month are available. (Premium feature will support full history)
         * @summary Get tx output(outpoint for vin) spent status.
         * @param {string} txid The txid of the output
         * @param {number} index The index of the output in the tx.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        outpointTxidIndexGet(txid: string, index: number, options?: any): AxiosPromise<OutputInfo> {
            return OutpointApiFp(configuration).outpointTxidIndexGet(txid, index, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OutpointApi - object-oriented interface
 * @export
 * @class OutpointApi
 * @extends {BaseAPI}
 */
export class OutpointApi extends BaseAPI {
    /**
     * Get detailed info for a utxo(or txo if spent), Only outputs spent no longer than one month are available. (Premium feature will support full history)
     * @summary Get tx output(outpoint for vin) spent status.
     * @param {string} txid The txid of the output
     * @param {number} index The index of the output in the tx.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OutpointApi
     */
    public outpointTxidIndexGet(txid: string, index: number, options?: any) {
        return OutpointApiFp(this.configuration).outpointTxidIndexGet(txid, index, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TreasuryApi - axios parameter creator
 * @export
 */
export const TreasuryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get current treasury info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        treasuryGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/treasury`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all treasury history.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        treasuryHistoryGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/treasury/history`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TreasuryApi - functional programming interface
 * @export
 */
export const TreasuryApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get current treasury info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async treasuryGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TreasuryInfo>> {
            const localVarAxiosArgs = await TreasuryApiAxiosParamCreator(configuration).treasuryGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get all treasury history.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async treasuryHistoryGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TreasuryHistory>>> {
            const localVarAxiosArgs = await TreasuryApiAxiosParamCreator(configuration).treasuryHistoryGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TreasuryApi - factory interface
 * @export
 */
export const TreasuryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Get current treasury info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        treasuryGet(options?: any): AxiosPromise<TreasuryInfo> {
            return TreasuryApiFp(configuration).treasuryGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all treasury history.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        treasuryHistoryGet(options?: any): AxiosPromise<Array<TreasuryHistory>> {
            return TreasuryApiFp(configuration).treasuryHistoryGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TreasuryApi - object-oriented interface
 * @export
 * @class TreasuryApi
 * @extends {BaseAPI}
 */
export class TreasuryApi extends BaseAPI {
    /**
     * 
     * @summary Get current treasury info.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TreasuryApi
     */
    public treasuryGet(options?: any) {
        return TreasuryApiFp(this.configuration).treasuryGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all treasury history.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TreasuryApi
     */
    public treasuryHistoryGet(options?: any) {
        return TreasuryApiFp(this.configuration).treasuryHistoryGet(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TxApi - axios parameter creator
 * @export
 */
export const TxApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This api will broadcast to MvcApi fullnode directly.
         * @summary Broadcast a batch of tx to MvcApi fullnode. This endpoint use rpc sendrawtransactions.
         * @param {Array<TxRaw>} [txRaw] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        txBroadcastBatchPost: async (txRaw?: Array<TxRaw>, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/tx/broadcast/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof txRaw !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(txRaw !== undefined ? txRaw : {})
                : (txRaw || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * This api will broadcast to MvcApi fullnode directly. This endpoint use rpc sendrawtransaction.
         * @summary Broadcast tx to MvcApi fullnode.
         * @param {TxRaw} [txRaw] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        txBroadcastPost: async (txRaw?: TxRaw, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/tx/broadcast`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof txRaw !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(txRaw !== undefined ? txRaw : {})
                : (txRaw || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * This api is parsed from raw hex, you can use /tx/{txid}/raw to parse tx by yourself, If you want detail input info, use \'/vin/{txid}\' to get detailed input info including address and value.
         * @summary Get transaction detail by specific txid.
         * @param {string} txid the request ID to search, txhash
         * @param {boolean} [showScript] Return source script code or not (default false).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        txTxidGet: async (txid: string, showScript?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'txid' is not null or undefined
            if (txid === null || txid === undefined) {
                throw new RequiredError('txid','Required parameter txid was null or undefined when calling txTxidGet.');
            }
            const localVarPath = `/tx/{txid}`
                .replace(`{${"txid"}}`, encodeURIComponent(String(txid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (showScript !== undefined) {
                localVarQueryParameter['showScript'] = showScript;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get transaction raw hex by specific txid.
         * @param {string} txid the request ID to search, txhash
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        txTxidRawGet: async (txid: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'txid' is not null or undefined
            if (txid === null || txid === undefined) {
                throw new RequiredError('txid','Required parameter txid was null or undefined when calling txTxidRawGet.');
            }
            const localVarPath = `/tx/{txid}/raw`
                .replace(`{${"txid"}}`, encodeURIComponent(String(txid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Whether MvcApi have seen this tx before. This is a fast approach to know if the tx exist or not.
         * @param {string} txid the request ID to search, txhash
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        txTxidSeenGet: async (txid: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'txid' is not null or undefined
            if (txid === null || txid === undefined) {
                throw new RequiredError('txid','Required parameter txid was null or undefined when calling txTxidSeenGet.');
            }
            const localVarPath = `/tx/{txid}/seen`
                .replace(`{${"txid"}}`, encodeURIComponent(String(txid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Search output points by spent txid. Use this api to get detailed inputs for the tx.
         * @summary Get all output point of vins in the tx with detailed output script.
         * @param {string} txid The txid of the vins
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vinTxidDetailGet: async (txid: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'txid' is not null or undefined
            if (txid === null || txid === undefined) {
                throw new RequiredError('txid','Required parameter txid was null or undefined when calling vinTxidDetailGet.');
            }
            const localVarPath = `/vin/{txid}/detail`
                .replace(`{${"txid"}}`, encodeURIComponent(String(txid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TxApi - functional programming interface
 * @export
 */
export const TxApiFp = function(configuration?: Configuration) {
    return {
        /**
         * This api will broadcast to MvcApi fullnode directly.
         * @summary Broadcast a batch of tx to MvcApi fullnode. This endpoint use rpc sendrawtransactions.
         * @param {Array<TxRaw>} [txRaw] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async txBroadcastBatchPost(txRaw?: Array<TxRaw>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BatchBroadcastResult>> {
            const localVarAxiosArgs = await TxApiAxiosParamCreator(configuration).txBroadcastBatchPost(txRaw, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * This api will broadcast to MvcApi fullnode directly. This endpoint use rpc sendrawtransaction.
         * @summary Broadcast tx to MvcApi fullnode.
         * @param {TxRaw} [txRaw] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async txBroadcastPost(txRaw?: TxRaw, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BroadcastResult>> {
            const localVarAxiosArgs = await TxApiAxiosParamCreator(configuration).txBroadcastPost(txRaw, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * This api is parsed from raw hex, you can use /tx/{txid}/raw to parse tx by yourself, If you want detail input info, use \'/vin/{txid}\' to get detailed input info including address and value.
         * @summary Get transaction detail by specific txid.
         * @param {string} txid the request ID to search, txhash
         * @param {boolean} [showScript] Return source script code or not (default false).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async txTxidGet(txid: string, showScript?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TxDetail>> {
            const localVarAxiosArgs = await TxApiAxiosParamCreator(configuration).txTxidGet(txid, showScript, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get transaction raw hex by specific txid.
         * @param {string} txid the request ID to search, txhash
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async txTxidRawGet(txid: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TxRaw>> {
            const localVarAxiosArgs = await TxApiAxiosParamCreator(configuration).txTxidRawGet(txid, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Whether MvcApi have seen this tx before. This is a fast approach to know if the tx exist or not.
         * @param {string} txid the request ID to search, txhash
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async txTxidSeenGet(txid: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await TxApiAxiosParamCreator(configuration).txTxidSeenGet(txid, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Search output points by spent txid. Use this api to get detailed inputs for the tx.
         * @summary Get all output point of vins in the tx with detailed output script.
         * @param {string} txid The txid of the vins
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async vinTxidDetailGet(txid: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OutputInfoDetail>>> {
            const localVarAxiosArgs = await TxApiAxiosParamCreator(configuration).vinTxidDetailGet(txid, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TxApi - factory interface
 * @export
 */
export const TxApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * This api will broadcast to MvcApi fullnode directly.
         * @summary Broadcast a batch of tx to MvcApi fullnode. This endpoint use rpc sendrawtransactions.
         * @param {Array<TxRaw>} [txRaw] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        txBroadcastBatchPost(txRaw?: Array<TxRaw>, options?: any): AxiosPromise<BatchBroadcastResult> {
            return TxApiFp(configuration).txBroadcastBatchPost(txRaw, options).then((request) => request(axios, basePath));
        },
        /**
         * This api will broadcast to MvcApi fullnode directly. This endpoint use rpc sendrawtransaction.
         * @summary Broadcast tx to MvcApi fullnode.
         * @param {TxRaw} [txRaw] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        txBroadcastPost(txRaw?: TxRaw, options?: any): AxiosPromise<BroadcastResult> {
            return TxApiFp(configuration).txBroadcastPost(txRaw, options).then((request) => request(axios, basePath));
        },
        /**
         * This api is parsed from raw hex, you can use /tx/{txid}/raw to parse tx by yourself, If you want detail input info, use \'/vin/{txid}\' to get detailed input info including address and value.
         * @summary Get transaction detail by specific txid.
         * @param {string} txid the request ID to search, txhash
         * @param {boolean} [showScript] Return source script code or not (default false).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        txTxidGet(txid: string, showScript?: boolean, options?: any): AxiosPromise<TxDetail> {
            return TxApiFp(configuration).txTxidGet(txid, showScript, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get transaction raw hex by specific txid.
         * @param {string} txid the request ID to search, txhash
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        txTxidRawGet(txid: string, options?: any): AxiosPromise<TxRaw> {
            return TxApiFp(configuration).txTxidRawGet(txid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Whether MvcApi have seen this tx before. This is a fast approach to know if the tx exist or not.
         * @param {string} txid the request ID to search, txhash
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        txTxidSeenGet(txid: string, options?: any): AxiosPromise<boolean> {
            return TxApiFp(configuration).txTxidSeenGet(txid, options).then((request) => request(axios, basePath));
        },
        /**
         * Search output points by spent txid. Use this api to get detailed inputs for the tx.
         * @summary Get all output point of vins in the tx with detailed output script.
         * @param {string} txid The txid of the vins
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vinTxidDetailGet(txid: string, options?: any): AxiosPromise<Array<OutputInfoDetail>> {
            return TxApiFp(configuration).vinTxidDetailGet(txid, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TxApi - object-oriented interface
 * @export
 * @class TxApi
 * @extends {BaseAPI}
 */
export class TxApi extends BaseAPI {
    /**
     * This api will broadcast to MvcApi fullnode directly.
     * @summary Broadcast a batch of tx to MvcApi fullnode. This endpoint use rpc sendrawtransactions.
     * @param {Array<TxRaw>} [txRaw] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TxApi
     */
    public txBroadcastBatchPost(txRaw?: Array<TxRaw>, options?: any) {
        return TxApiFp(this.configuration).txBroadcastBatchPost(txRaw, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This api will broadcast to MvcApi fullnode directly. This endpoint use rpc sendrawtransaction.
     * @summary Broadcast tx to MvcApi fullnode.
     * @param {TxRaw} [txRaw] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TxApi
     */
    public txBroadcastPost(txRaw?: TxRaw, options?: any) {
        return TxApiFp(this.configuration).txBroadcastPost(txRaw, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This api is parsed from raw hex, you can use /tx/{txid}/raw to parse tx by yourself, If you want detail input info, use \'/vin/{txid}\' to get detailed input info including address and value.
     * @summary Get transaction detail by specific txid.
     * @param {string} txid the request ID to search, txhash
     * @param {boolean} [showScript] Return source script code or not (default false).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TxApi
     */
    public txTxidGet(txid: string, showScript?: boolean, options?: any) {
        return TxApiFp(this.configuration).txTxidGet(txid, showScript, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get transaction raw hex by specific txid.
     * @param {string} txid the request ID to search, txhash
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TxApi
     */
    public txTxidRawGet(txid: string, options?: any) {
        return TxApiFp(this.configuration).txTxidRawGet(txid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Whether MvcApi have seen this tx before. This is a fast approach to know if the tx exist or not.
     * @param {string} txid the request ID to search, txhash
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TxApi
     */
    public txTxidSeenGet(txid: string, options?: any) {
        return TxApiFp(this.configuration).txTxidSeenGet(txid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search output points by spent txid. Use this api to get detailed inputs for the tx.
     * @summary Get all output point of vins in the tx with detailed output script.
     * @param {string} txid The txid of the vins
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TxApi
     */
    public vinTxidDetailGet(txid: string, options?: any) {
        return TxApiFp(this.configuration).vinTxidDetailGet(txid, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * XpubApi - axios parameter creator
 * @export
 */
export const XpubApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get xpub address type and index. Only index under /0/70 /1/30 is valid. Otherwise not found.
         * @param {string} xpub the requested xpub
         * @param {string} address the requested address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        xpubLiteXpubAddressAddressGet: async (xpub: string, address: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'xpub' is not null or undefined
            if (xpub === null || xpub === undefined) {
                throw new RequiredError('xpub','Required parameter xpub was null or undefined when calling xpubLiteXpubAddressAddressGet.');
            }
            // verify required parameter 'address' is not null or undefined
            if (address === null || address === undefined) {
                throw new RequiredError('address','Required parameter address was null or undefined when calling xpubLiteXpubAddressAddressGet.');
            }
            const localVarPath = `/xpubLite/{xpub}/address/{address}`
                .replace(`{${"xpub"}}`, encodeURIComponent(String(xpub)))
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * This api returns confirmed balance(same as address balance), not sumed utxos.
         * @summary Get xpub balances including confirmed and unconfirmed.
         * @param {string} xpub the xpub to search
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        xpubLiteXpubBalanceGet: async (xpub: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'xpub' is not null or undefined
            if (xpub === null || xpub === undefined) {
                throw new RequiredError('xpub','Required parameter xpub was null or undefined when calling xpubLiteXpubBalanceGet.');
            }
            const localVarPath = `/xpubLite/{xpub}/balance`
                .replace(`{${"xpub"}}`, encodeURIComponent(String(xpub)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get xpub utxos by specific xpub(300 per page).
         * @param {string} xpub the requested xpub
         * @param {number} [limit] The max items returned in this query(default 300), not bigger than 5000.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        xpubLiteXpubUtxoGet: async (xpub: string, limit?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'xpub' is not null or undefined
            if (xpub === null || xpub === undefined) {
                throw new RequiredError('xpub','Required parameter xpub was null or undefined when calling xpubLiteXpubUtxoGet.');
            }
            const localVarPath = `/xpubLite/{xpub}/utxo`
                .replace(`{${"xpub"}}`, encodeURIComponent(String(xpub)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * XpubApi - functional programming interface
 * @export
 */
export const XpubApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get xpub address type and index. Only index under /0/70 /1/30 is valid. Otherwise not found.
         * @param {string} xpub the requested xpub
         * @param {string} address the requested address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async xpubLiteXpubAddressAddressGet(xpub: string, address: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<XpubAddress>> {
            const localVarAxiosArgs = await XpubApiAxiosParamCreator(configuration).xpubLiteXpubAddressAddressGet(xpub, address, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * This api returns confirmed balance(same as address balance), not sumed utxos.
         * @summary Get xpub balances including confirmed and unconfirmed.
         * @param {string} xpub the xpub to search
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async xpubLiteXpubBalanceGet(xpub: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<XpubLiteBalance>> {
            const localVarAxiosArgs = await XpubApiAxiosParamCreator(configuration).xpubLiteXpubBalanceGet(xpub, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get xpub utxos by specific xpub(300 per page).
         * @param {string} xpub the requested xpub
         * @param {number} [limit] The max items returned in this query(default 300), not bigger than 5000.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async xpubLiteXpubUtxoGet(xpub: string, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<XpubUtxo>>> {
            const localVarAxiosArgs = await XpubApiAxiosParamCreator(configuration).xpubLiteXpubUtxoGet(xpub, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * XpubApi - factory interface
 * @export
 */
export const XpubApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Get xpub address type and index. Only index under /0/70 /1/30 is valid. Otherwise not found.
         * @param {string} xpub the requested xpub
         * @param {string} address the requested address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        xpubLiteXpubAddressAddressGet(xpub: string, address: string, options?: any): AxiosPromise<XpubAddress> {
            return XpubApiFp(configuration).xpubLiteXpubAddressAddressGet(xpub, address, options).then((request) => request(axios, basePath));
        },
        /**
         * This api returns confirmed balance(same as address balance), not sumed utxos.
         * @summary Get xpub balances including confirmed and unconfirmed.
         * @param {string} xpub the xpub to search
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        xpubLiteXpubBalanceGet(xpub: string, options?: any): AxiosPromise<XpubLiteBalance> {
            return XpubApiFp(configuration).xpubLiteXpubBalanceGet(xpub, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get xpub utxos by specific xpub(300 per page).
         * @param {string} xpub the requested xpub
         * @param {number} [limit] The max items returned in this query(default 300), not bigger than 5000.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        xpubLiteXpubUtxoGet(xpub: string, limit?: number, options?: any): AxiosPromise<Array<XpubUtxo>> {
            return XpubApiFp(configuration).xpubLiteXpubUtxoGet(xpub, limit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * XpubApi - object-oriented interface
 * @export
 * @class XpubApi
 * @extends {BaseAPI}
 */
export class XpubApi extends BaseAPI {
    /**
     * 
     * @summary Get xpub address type and index. Only index under /0/70 /1/30 is valid. Otherwise not found.
     * @param {string} xpub the requested xpub
     * @param {string} address the requested address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof XpubApi
     */
    public xpubLiteXpubAddressAddressGet(xpub: string, address: string, options?: any) {
        return XpubApiFp(this.configuration).xpubLiteXpubAddressAddressGet(xpub, address, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This api returns confirmed balance(same as address balance), not sumed utxos.
     * @summary Get xpub balances including confirmed and unconfirmed.
     * @param {string} xpub the xpub to search
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof XpubApi
     */
    public xpubLiteXpubBalanceGet(xpub: string, options?: any) {
        return XpubApiFp(this.configuration).xpubLiteXpubBalanceGet(xpub, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get xpub utxos by specific xpub(300 per page).
     * @param {string} xpub the requested xpub
     * @param {number} [limit] The max items returned in this query(default 300), not bigger than 5000.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof XpubApi
     */
    public xpubLiteXpubUtxoGet(xpub: string, limit?: number, options?: any) {
        return XpubApiFp(this.configuration).xpubLiteXpubUtxoGet(xpub, limit, options).then((request) => request(this.axios, this.basePath));
    }
}


